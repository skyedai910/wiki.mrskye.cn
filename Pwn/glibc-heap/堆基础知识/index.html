
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="SkYe Wiki">
      
      
      
        <meta name="author" content="SkYe231">
      
      
        <link rel="canonical" href="https://wiki.mrskye.cn/Pwn/glibc-heap/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
      
      <link rel="shortcut icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.4">
    
    
      
        <title>堆概述 - SkYe Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.15aa0b43.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.75751829.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans:300,400,400i,700%7CSource+Code+Pro&display=fallback">
        <style>body,input{font-family:"Noto Sans",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Source Code Pro",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
        
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-36723568-3","wiki.mrskye.cn"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview",document.location.pathname)})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="green">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://wiki.mrskye.cn/" title="SkYe Wiki" class="md-header-nav__button md-logo" aria-label="SkYe Wiki">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 22a2 2 0 002-2V4a2 2 0 00-2-2h-6v7L9.5 7.5 7 9V2H6a2 2 0 00-2 2v16a2 2 0 002 2h12z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            SkYe Wiki
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              堆概述
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/skyedai910/wiki.mrskye.cn/" title="前往 GitHub 仓库" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    skyedai910/wiki.mrskye.cn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://wiki.mrskye.cn/" title="SkYe Wiki" class="md-nav__button md-logo" aria-label="SkYe Wiki">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 22a2 2 0 002-2V4a2 2 0 00-2-2h-6v7L9.5 7.5 7 9V2H6a2 2 0 00-2 2v16a2 2 0 002 2h12z"/></svg>

    </a>
    SkYe Wiki
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/skyedai910/wiki.mrskye.cn/" title="前往 GitHub 仓库" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    skyedai910/wiki.mrskye.cn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      



  
  <li class="md-nav__item md-nav__item--nested">
    
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" >
    
    <label class="md-nav__link" for="nav-1">
      Pwn
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Pwn" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        <span class="md-nav__icon md-icon"></span>
        Pwn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          



  
  <li class="md-nav__item md-nav__item--nested">
    
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-1-1" type="checkbox" id="nav-1-1" >
    
    <label class="md-nav__link" for="nav-1-1">
      格式化字符串
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="格式化字符串" data-md-level="2">
      <label class="md-nav__title" for="nav-1-1">
        <span class="md-nav__icon md-icon"></span>
        格式化字符串
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          



  <li class="md-nav__item">
    <a href="../../fmtstr/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/" class="md-nav__link">
      格式化字符串漏洞基础例子
    </a>
  </li>

        
          
          
          



  <li class="md-nav__item">
    <a href="../../fmtstr/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8/" class="md-nav__link">
      格式化字符串漏洞基础利用
    </a>
  </li>

        
          
          
          



  <li class="md-nav__item">
    <a href="../../fmtstr/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B2%E6%89%93/Bilnd_Pwn/" class="md-nav__link">
      格式化字符串盲打
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    什么是堆
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    堆的基本操作
  </a>
  
    <nav class="md-nav" aria-label="堆的基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#malloc" class="md-nav__link">
    malloc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#free" class="md-nav__link">
    free
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    内存分配背后的系统调用
  </a>
  
    <nav class="md-nav" aria-label="内存分配背后的系统调用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sbrk" class="md-nav__link">
    (s)brk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mmap" class="md-nav__link">
    mmap
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    多线程支持
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/skyedai910/wiki.mrskye.cn/blob/master/docs/Pwn/glibc-heap/堆基础知识.md" title="编辑此页" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="_1">堆概述<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<blockquote>
<p>内容绝大部分来自ctf-wiki，文章用于自己学习记录</p>
</blockquote>
<h2 id="_2">什么是堆<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>在程序运行过程中，<strong>堆可以提供动态分配的内存</strong>，允许程序申请大小未知的内存<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ol>
<li>响应用户的申请内存请求，向操作系统**申请内存**，然后将其返回给用户程序。同时，为了保持内存管理的高效性，<strong>内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互</strong>。</li>
<li><strong>管理用户所释放的内存</strong>。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ol>
<p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h2 id="_3">堆的基本操作<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>这里我们主要介绍</p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li>
<li>介绍堆目前的多线程支持。</li>
</ul>
<h3 id="malloc">malloc<a class="headerlink" href="#malloc" title="Permanent link">&para;</a></h3>
<p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p>
<div class="highlight"><pre><span></span><code>/*
  malloc(size_t n)
  Returns a pointer to a newly allocated chunk of at least n bytes, or null
  if no space is available. Additionally, on failure, errno is
  set to ENOMEM on ANSI C systems.
  If n is zero, malloc returns a minumum-sized chunk. (The minimum
  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit
  systems.)  On most systems, size_t is an unsigned type, so calls
  with negative arguments are interpreted as requests for huge amounts
  of space, which will often fail. The maximum supported value of n
  differs across systems, but is in all cases less than the maximum
  representable value of a size_t.
*/
</code></pre></div>
<p>可以看出，malloc 函数返回对应大小字节的内存块的**指针**<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>。此外，该函数还对一些异常情况进行了处理</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是<code>无符号数</code>（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<h3 id="free">free<a class="headerlink" href="#free" title="Permanent link">&para;</a></h3>
<p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p>
<div class="highlight"><pre><span></span><code>/*
      free(void* p)
      Releases the chunk of memory pointed to by p, that had been previously
      allocated using malloc or a related routine such as realloc.
      It has no effect if p is null. It can have arbitrary (i.e., bad!)
      effects if p has already been freed.
      Unless disabled (using mallopt), freeing very large spaces will
      when possible, automatically trigger operations that give
      back unused memory to the system, thus reducing program footprint.
    */
</code></pre></div>
<p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理</p>
<ul>
<li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup></li>
</ul>
<h3 id="_4">内存分配背后的系统调用<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。<sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup></p>
<p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p>
<p><img alt="brk&amp;mmap.png" src="../img/brk%26mmap.png" /></p>
<h4 id="sbrk">(s)brk<a class="headerlink" href="#sbrk" title="Permanent link">&para;</a></h4>
<p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a href="https://en.wikipedia.org/wiki/Sbrk">brk</a> 的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p>具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示</p>
<p><img alt="program_virtual_address_memory_space.png" src="../img/program_virtual_address_memory_space.png" /></p>
<p><strong>例子</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* sbrk and brk example */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">curr_brk</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_brk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Welcome to sbrk example:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

        <span class="cm">/* sbrk(0) gives current program break location */</span>
        <span class="n">tmp_brk</span> <span class="o">=</span> <span class="n">curr_brk</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Program Break Location1:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_brk</span><span class="p">);</span>
        <span class="n">getchar</span><span class="p">();</span>

        <span class="cm">/* brk(addr) increments/decrements program break location */</span>
        <span class="n">brk</span><span class="p">(</span><span class="n">curr_brk</span><span class="o">+</span><span class="mi">4096</span><span class="p">);</span>

        <span class="n">curr_brk</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Program break Location2:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_brk</span><span class="p">);</span>
        <span class="n">getchar</span><span class="p">();</span>

        <span class="n">brk</span><span class="p">(</span><span class="n">tmp_brk</span><span class="p">);</span>

        <span class="n">curr_brk</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Program Break Location3:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_brk</span><span class="p">);</span>
        <span class="n">getchar</span><span class="p">();</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//gcc sbrk_brk_example.c -m32 -o ./sbrk_brk_example</span>
</code></pre></div>
<p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p>
<p><strong>在第一次调用 brk 之前</strong></p>
<p>从下面的输出可以看出，并没有出现堆。因此</p>
<ul>
<li>start_brk = brk = end_data = 0x806c000</li>
</ul>
<p><img alt="chunk0.png" src="../img/chunk0.png" /></p>
<p><strong>第一次增加 brk 后</strong></p>
<p>从下面的输出可以看出，已经出现了堆段</p>
<ul>
<li>start_brk = end_data = 0x806c000</li>
<li>brk = 0x806d000</li>
</ul>
<p><img alt="chunk1.png" src="../img/chunk1.png" /></p>
<p>其中，关于堆的那一行</p>
<ul>
<li>0x806c000是相应堆的起始地址</li>
<li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li>
<li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
<li>00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li>
<li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
</ul>
<p>然后通过 <code>brk(tmp_brk);</code> 将指针归位回到 0x806c000 ，新出现的 heap 消失。具体和第一步图一样，不贴图了。</p>
<h4 id="mmap">mmap<a class="headerlink" href="#mmap" title="Permanent link">&para;</a></h4>
<p>malloc 会使用 <a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p><strong>例子</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Private anonymous mapping example using mmap syscall */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="k">static</span> <span class="kr">inline</span> <span class="n">errExit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s failed. Exiting the process</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Welcome to private anonymous mapping example::PID:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before mmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">getchar</span><span class="p">();</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">132</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
                <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After mmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">getchar</span><span class="p">();</span>

        <span class="cm">/* Unmap mapped region. */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">132</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span>
                <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;munmap&quot;</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After munmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">getchar</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>在执行 mmap 之前</strong></p>
<p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps
<span class="m">08048000</span>-08049000 r-xp <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
<span class="m">08049000</span>-0804a000 r--p <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
0804a000-0804b000 rw-p <span class="m">00001000</span> <span class="m">08</span>:01 <span class="m">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
b7e21000-b7e22000 rw-p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$
</code></pre></div>
<p><strong>mmap 后</strong></p>
<p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps
<span class="m">08048000</span>-08049000 r-xp <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
<span class="m">08049000</span>-0804a000 r--p <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
0804a000-0804b000 rw-p <span class="m">00001000</span> <span class="m">08</span>:01 <span class="m">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
b7e00000-b7e22000 rw-p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$
</code></pre></div>
<p><strong>munmap</strong></p>
<p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps
08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap
b7e21000-b7e22000 rw-p 00000000 00:00 0
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$
</code></pre></div>
<h3 id="_5">多线程支持<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
<p>这里给出一个例子。</p>
<div class="highlight"><pre><span></span><code>/* Per thread arena example. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

void* threadFunc(void* arg) {
        printf(&quot;Before malloc in thread 1\n&quot;);
        getchar();
        char* addr = (char*) malloc(1000);
        printf(&quot;After malloc and before free in thread 1\n&quot;);
        getchar();
        free(addr);
        printf(&quot;After free in thread 1\n&quot;);
        getchar();
}

int main() {
        pthread_t t1;
        void* s;
        int ret;
        char* addr;

        printf(&quot;Welcome to per thread arena example::%d\n&quot;,getpid());
        printf(&quot;Before malloc in main thread\n&quot;);
        getchar();
        addr = (char*) malloc(1000);
        printf(&quot;After malloc and before free in main thread\n&quot;);
        getchar();
        free(addr);
        printf(&quot;After free in main thread\n&quot;);
        getchar();
        ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);
        if(ret)
        {
                printf(&quot;Thread creation error\n&quot;);
                return -1;
        }
        ret = pthread_join(t1, &amp;s);
        if(ret)
        {
                printf(&quot;Thread join error\n&quot;);
                return -1;
        }
        return 0;
}
</code></pre></div>
<p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
b7e05000-b7e07000 rw-p 00000000 00:00 0
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$
</code></pre></div>
<p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000=0x21000 个字节的堆。**这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。**我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
...
sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e05000-b7e07000 rw-p 00000000 00:00 0
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$
</code></pre></div>
<p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
...
sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7e05000-b7e07000 rw-p 00000000 00:00 0
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$
</code></pre></div>
<p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7604000-b7605000 ---p 00000000 00:00 0
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$
</code></pre></div>
<p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p>
<p>注意：</p>
<blockquote>
<p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
</blockquote>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
After malloc and before free in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7500000-b7521000 rw-p 00000000 00:00 0
b7521000-b7600000 ---p 00000000 00:00 0
b7604000-b7605000 ---p 00000000 00:00 0
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$
</code></pre></div>
<p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<div class="highlight"><pre><span></span><code>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread
Welcome to per thread arena example::6501
Before malloc in main thread
After malloc and before free in main thread
After free in main thread
Before malloc in thread 1
After malloc and before free in thread 1
After free in thread 1
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps
08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7500000-b7521000 rw-p 00000000 00:00 0
b7521000-b7600000 ---p 00000000 00:00 0
b7604000-b7605000 ---p 00000000 00:00 0
b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]
...
sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$
</code></pre></div>
<h1 id="_6">堆相关数据结构<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h1>
<blockquote>
<p>内容绝大部分来自ctf-wiki，文章用于自己学习记录</p>
</blockquote>
<p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p>
<ul>
<li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li>
<li>微观结构，用于具体处理堆的分配与回收中的内存块。</li>
</ul>
<h2 id="_7">宏观结构<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<h3 id="32">32位内存布局<a class="headerlink" href="#32" title="Permanent link">&para;</a></h3>
<p><img alt="32位内存布局" src="img\32mem.png" /></p>
<p>从高地址到低地址为：不可访问的内核空间，栈空间（由高地址向低地址生长），内存布局区，堆空间（由低地址向高地址生长），BSS，数据段，文本段。本报告讨论进程的栈空间和堆空间的具体结构。</p>
<h3 id="64">64位内存布局<a class="headerlink" href="#64" title="Permanent link">&para;</a></h3>
<p>用户空间的布局和32位差别很小。</p>
<p><img alt="64位内存布局" src="img\64mem.png" /></p>
<h3 id="_8">堆管理介绍<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<h4 id="3">3 种数据结构<a class="headerlink" href="#3" title="Permanent link">&para;</a></h4>
<p>在 <code>glibc</code> 的 <code>malloc</code> 中针对堆管理，主要涉及到以下 3 种数据结构：</p>
<ul>
<li>heap_info（即Heap Header）对应管理 heap</li>
<li>malloc_state（即Arena Header） 对应管理 area</li>
<li>malloc_chunk（即Chunk Header） 对应管理 chunk</li>
</ul>
<blockquote>
<p>这里堆管理会出现在多线程，一般pwn题不会涉及多线程操作，也就是都是在 main_area 上操作，因此可选择性阅读 heap_info、malloc_state。</p>
</blockquote>
<h5 id="heap_info">heap_info<a class="headerlink" href="#heap_info" title="Permanent link">&para;</a></h5>
<p>heap_info: 即Heap Header，因为一个**thread arena**（注意：不包含**main thread**）可以包含多个heaps，所以为了便于管理，就给每个 heap 分配一个 heap  header。那么在什么情况下一个thread arena会包含多个 heaps 呢?在当前 heap 不够用的时候，malloc 会通过系统调用 mmap 申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_heap_info</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span> <span class="cm">/* Arena for this heap. */</span>
  <span class="k">struct</span> <span class="nc">_heap_info</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="cm">/* Previous heap. */</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>   <span class="cm">/* Current size in bytes. */</span>
  <span class="kt">size_t</span> <span class="n">mprotect_size</span><span class="p">;</span> <span class="cm">/* Size in bytes that has been mprotected</span>
<span class="cm">                           PROT_READ|PROT_WRITE.  */</span>
  <span class="cm">/* Make sure the following data is properly aligned, particularly</span>
<span class="cm">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span>
<span class="cm">     MALLOC_ALIGNMENT. */</span>
  <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">-6</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">];</span>
<span class="p">}</span> <span class="n">heap_info</span><span class="p">;</span>
</code></pre></div>
<h6 id="arena">Arena 数量限制<a class="headerlink" href="#arena" title="Permanent link">&para;</a></h6>
<p>主线程和子线程有自己独立的 <em>arena</em>，那么是不是无论有多少个线程，每个线程都有自己独立的 <em>arena</em> 呢？答案是否定的。事实上，*arena*的个数是跟系统中处理器核心个数相关的，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">systems</th>
<th align="center">number of arena</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">32bits</td>
<td align="center">2 x number of cpu cores + 1</td>
</tr>
<tr>
<td align="center">64bits</td>
<td align="center">8 x number of cpu cores + 1</td>
</tr>
</tbody>
</table>
<h6 id="arena_1">Arena 管理<a class="headerlink" href="#arena_1" title="Permanent link">&para;</a></h6>
<p>假设有如下情景：一台只含有一个处理器核心的机器安装有 32 位操作系统，其上运行了一个多线程应用程序，共含有 4 个线程——主线程和三个子线程。显然线程个数大于系统能维护的最大 <em>arena</em> 个数（2 x 核心数 + 1= 3），那么此时 <code>glibc</code> 的 <code>malloc</code> 就需要确保这 4 个线程能够正确地共享这 3 个 <em>arena</em>，那么它是如何实现的呢？</p>
<p>当主线程首次调用 <code>malloc</code> 的时候会直接为它分配一个 <em>main arena</em>，而不需要任何附加条件。</p>
<p>当子线程 1 和子线程 2 首次调用 <code>malloc</code> 的时候，<code>glibc</code> 实现的 <code>malloc</code> 会分别为每个子线程创建一个新的 <em>thread arena</em>。此时，各个线程与 <em>arena</em> 是一一对应的。但是，当用户线程 3 调用 <code>malloc</code> 的时候就出现问题了。因为此时 <code>glibc</code> 的 <code>malloc</code> 能维护的 <em>arena</em> 个数已经达到上限，无法再为子线程 3 分配新的 <em>arena</em> 了，那么就需要重复使用已经分配好的 3 个 <em>arena</em> 中的一个（<em>main arena</em>, <em>arena1</em> 或者 <em>arena2</em>）。那么该选择哪个 <em>arena</em> 进行重复利用呢？<code>glibc</code> 的 <code>malloc</code> 遵循以下规则：</p>
<ol>
<li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li>
<li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止。</li>
<li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li>
</ol>
<p>这样子线程 3 与主线程就共享 <em>main arena</em> 了。至于其他更复杂的情况，以此类推。</p>
<h5 id="malloc_state">malloc_state<a class="headerlink" href="#malloc_state" title="Permanent link">&para;</a></h5>
<p>malloc_state: 即Arena Header，用于表示 area 的信息，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">malloc_state</span>
<span class="p">{</span>
  <span class="cm">/* Serialize access.  */</span>
  <span class="n">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="cm">/* Flags (formerly in max_fast).  */</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
  <span class="cm">/* Fastbins */</span>
  <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span>
  <span class="cm">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
  <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span>
  <span class="cm">/* The remainder from the most recent split of a small request */</span>
  <span class="n">mchunkptr</span> <span class="n">last_remainder</span><span class="p">;</span>
  <span class="cm">/* Normal bins packed as described above */</span>
  <span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span><span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
  <span class="cm">/* Bitmap of bins */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">binmap</span><span class="p">[</span><span class="n">BINMAPSIZE</span><span class="p">];</span>
  <span class="cm">/* Linked list */</span>
  <span class="k">struct</span> <span class="nc">malloc_state</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="cm">/* Linked list for free arenas.  */</span>
  <span class="k">struct</span> <span class="nc">malloc_state</span> <span class="o">*</span><span class="n">next_free</span><span class="p">;</span>
  <span class="cm">/* Memory allocated from the system in this arena.  */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">system_mem</span><span class="p">;</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_system_mem</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<h5 id="malloc_chunk">malloc_chunk<a class="headerlink" href="#malloc_chunk" title="Permanent link">&para;</a></h5>
<p>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size_t size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="nc">malloc_chunk</span> <span class="p">{</span>
  <span class="cm">/* #define INTERNAL_SIZE_T size_t */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>
  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>关于上述的结构（malloc_chunk主线程也用到），针对子线程的，主线程和子线程有一些不同：</p>
<ol>
<li>主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域（mapping）为止。</li>
<li>不同于 <em>thread arena</em>，主线程的 <em>main arena</em> 的 <em>arena header</em> 并不在堆区中，而是一个全局变量，因此它属于 <code>libc.so</code> 的 data segment 区域。</li>
</ol>
<h4 id="heap-segmentarena">heap segment与arena关系<a class="headerlink" href="#heap-segmentarena" title="Permanent link">&para;</a></h4>
<p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p>
<p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p>
<p><img alt="heap segment" src="img\heap segment.png" /></p>
<p>下图是一个thread arena中含有多个heap segments的情况：</p>
<p><img alt="heap segments" src="img\heap segments.png" /></p>
<p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p>
<h2 id="_9">微观结构<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<h3 id="chunk">chunk 介绍<a class="headerlink" href="#chunk" title="Permanent link">&para;</a></h3>
<h4 id="_10">概述<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<p>在 glibc malloc 中将整个堆内存空间分成了连续的、大小不一的 chunk ，即对于堆内存管理而言 chunk 就是最小操作单位。<em>chunk</em> 总共分为 4 大类：</p>
<ul>
<li><em>allocated chunk</em></li>
<li><em>free chunk</em></li>
<li><em>top chunk</em></li>
<li><em>last remainder chunk</em></li>
</ul>
<p>从本质上来说，所有类型的 <em>chunk</em> 都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。为了简便，也可以将这 4 大类 <em>chunk</em> 简化为 2 类：<em>allocated chunk</em> 以及 <em>free chunk</em>，前者表示已经分配给用户使用的 <em>chunk</em>，后者表示未使用的 <em>chunk</em>。</p>
<p>任何堆内存管理器都是以 <em>chunk</em> 为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为 <em>chunk</em> 的一部分嵌入到 <em>chunk</em> 内部。</p>
<p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构（malloc_chunk）。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</strong></p>
<h4 id="malloc_chunk-allocated-chunk">malloc_chunk (allocated chunk)<a class="headerlink" href="#malloc_chunk-allocated-chunk" title="Permanent link">&para;</a></h4>
<p>malloc_chunk 的结构如下:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">  This struct declaration is misleading (but accurate and necessary).</span>
<span class="cm">  It declares a &quot;view&quot; into memory allowing access to necessary</span>
<span class="cm">  fields at known offsets from a given base. See explanation below.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="nc">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>

  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="nc">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
<p>每个字段的具体的解释如下</p>
<ul>
<li><strong>prev_size</strong></li>
</ul>
<p>如果该 chunk 的**物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）<strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。**这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>
<ul>
<li><strong>size</strong></li>
</ul>
<p>该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>
<p>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p>
</li>
<li>
<p><strong>fd，bk</strong></p>
</li>
</ul>
<p>chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>
<p>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</p>
</li>
<li>
<p><strong>fd_nextsize， bk_nextsize</strong></p>
</li>
</ul>
<p>也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
<p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong></p>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<p>已经被分配使用的 <em>chunk</em> 结构如下两个图：（图一图二 size 位 A 与 N 相同含义只是表示不同）</p>
<div class="highlight"><pre><span></span><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             Size of previous chunk, <span class="k">if</span> unallocated <span class="o">(</span>P clear<span class="o">)</span>  <span class="p">|</span>
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             Size of chunk, <span class="k">in</span> bytes                     <span class="p">|</span>A<span class="p">|</span>M<span class="p">|</span>P<span class="p">|</span>
  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             User data starts here...                          .
        .                                                               .
        .             <span class="o">(</span>malloc_usable_size<span class="o">()</span> bytes<span class="o">)</span>                      .
next    .                                                               <span class="p">|</span>
chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             <span class="o">(</span>size of chunk, but used <span class="k">for</span> application data<span class="o">)</span>    <span class="p">|</span>
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             Size of next chunk, <span class="k">in</span> bytes                <span class="p">|</span>A<span class="p">|</span><span class="m">0</span><span class="p">|</span><span class="m">1</span><span class="p">|</span>
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div>
<p><img alt="allocated chunk" src="img\allocated-chunk.png" /></p>
<h4 id="free_chunk">free_chunk<a class="headerlink" href="#free_chunk" title="Permanent link">&para;</a></h4>
<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下：</p>
<div class="highlight"><pre><span></span><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             Size of previous chunk, <span class="k">if</span> unallocated <span class="o">(</span>P clear<span class="o">)</span>  <span class="p">|</span>
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="sb">`</span>head:<span class="s1">&#39; |             Size of chunk, in bytes                     |A|0|P|</span>
<span class="s1">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="s1">        |             Forward pointer to next chunk in list             |</span>
<span class="s1">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="s1">        |             Back pointer to previous chunk in list            |</span>
<span class="s1">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="s1">        |             Unused space (may be 0 bytes long)                .</span>
<span class="s1">        .                                                               .</span>
<span class="s1"> next   .                                                               |</span>
<span class="s1">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="s1">`foot:&#39;</span> <span class="p">|</span>             Size of chunk, <span class="k">in</span> bytes                           <span class="p">|</span>
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        <span class="p">|</span>             Size of next chunk, <span class="k">in</span> bytes                <span class="p">|</span>A<span class="p">|</span><span class="m">0</span><span class="p">|</span><span class="m">0</span><span class="p">|</span>
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div>
<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li>本身的 size 字段会记录。（图中最后一行 size 位）</li>
<li>它后面的 chunk 会记录。（图中倒数第二行 nextchunk 的 prevsize 位） </li>
</ol>
<p><strong>一般情况下</strong>（fastbin中存在特例），物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">    The three exceptions to all this are:</span>
<span class="cm">     1. The special chunk `top&#39; doesn&#39;t bother using the</span>
<span class="cm">    trailing size field since there is no next contiguous chunk</span>
<span class="cm">    that would have to index off it. After initialization, `top&#39;</span>
<span class="cm">    is forced to always exist.  If it would become less than</span>
<span class="cm">    MINSIZE bytes long, it is replenished.</span>
<span class="cm">     2. Chunks allocated via mmap, which have the second-lowest-order</span>
<span class="cm">    bit M (IS_MMAPPED) set in their size fields.  Because they are</span>
<span class="cm">    allocated one-by-one, each must contain its own trailing size</span>
<span class="cm">    field.  If the M bit is set, the other bits are ignored</span>
<span class="cm">    (because mmapped chunks are neither in an arena, nor adjacent</span>
<span class="cm">    to a freed chunk).  The M bit is also used for chunks which</span>
<span class="cm">    originally came from a dumped heap via malloc_set_state in</span>
<span class="cm">    hooks.c.</span>
<span class="cm">     3. Chunks in fastbins are treated as allocated chunks from the</span>
<span class="cm">    point of view of the chunk allocator.  They are consolidated</span>
<span class="cm">    with their neighbors only in bulk, in malloc_consolidate.</span>
<span class="cm">*/</span>
</code></pre></div>
<h4 id="top-chunk">top chunk<a class="headerlink" href="#top-chunk" title="Permanent link">&para;</a></h4>
<p>glibc 中对于 top chunk 的描述如下</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">   Top</span>

<span class="cm">    The top-most available chunk (i.e., the one bordering the end of</span>
<span class="cm">    available memory) is treated specially. It is never included in</span>
<span class="cm">    any bin, is used only if no other chunk is available, and is</span>
<span class="cm">    released back to the system if it is very large (see</span>
<span class="cm">    M_TRIM_THRESHOLD).  Because top initially</span>
<span class="cm">    points to its own bin with initial zero size, thus forcing</span>
<span class="cm">    extension on the first malloc request, we avoid having any special</span>
<span class="cm">    code in malloc to check whether it even exists yet. But we still</span>
<span class="cm">    need to do so when getting memory from system, so we make</span>
<span class="cm">    initial_top treat the bin as a legal but unusable chunk during the</span>
<span class="cm">    interval between initialization and the first call to</span>
<span class="cm">    sysmalloc. (This is somewhat delicate, since it relies on</span>
<span class="cm">    the 2 preceding words to be zero during this interval as well.)</span>
<span class="cm"> */</span>

<span class="cm">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span>
<span class="cp">#define initial_top(M) (unsorted_chunks(M))</span>
</code></pre></div>
<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。<strong>top chunk 不属于任何一个 bin</strong>，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果 <em>top chunk</em> 大小不小于用户请求的大小，就将该 <em>top chunk</em> 分作两部分：用户请求的 <em>chunk</em> 和 剩余的部分（成为新的 <em>top chunk</em>）。否则，就对 heap 进行扩展后再进行分配。在 <em>main arena</em> 中通过 <code>sbrk</code> 扩展 <em>heap</em>，而在*thread arena* 中通过 <code>mmap</code> 分配新的 <em>heap</em>。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
<h4 id="last-remainder">last remainder<a class="headerlink" href="#last-remainder" title="Permanent link">&para;</a></h4>
<p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk （bin中的chunk）可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为 last remainder。</p>
<h4 id="chunk_1">chunk 相关宏<a class="headerlink" href="#chunk_1" title="Permanent link">&para;</a></h4>
<p>这里主要介绍 chunk 的大小、对齐检查以及一些转换的宏。</p>
<p><strong>chunk 与 mem 指针头部的转换</strong></p>
<p>mem 指向用户得到的内存的起始位置。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* conversion from malloc headers to user pointers, and back */</span>
<span class="cp">#define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span>
<span class="cp">#define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span>
</code></pre></div>
<p><strong>最小的 chunk 大小</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* The smallest possible chunk */</span>
<span class="cp">#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span>
</code></pre></div>
<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* The smallest size we can malloc is an aligned minimal chunk */</span>
<span class="c1">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span>
<span class="cp">#define MINSIZE                                                                \</span>
<span class="cp">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span>
<span class="cp">                      ~MALLOC_ALIGN_MASK))</span>
</code></pre></div>
<p><strong>检查分配给用户的内存是否对齐</strong></p>
<p>2 * SIZE_SZ 大小对齐。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Check if m has acceptable alignment */</span>
<span class="c1">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span>
<span class="cp">#define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span>

<span class="cp">#define misaligned_chunk(p)                                                    \</span>
<span class="cp">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span>
<span class="cp">     MALLOC_ALIGN_MASK)</span>
</code></pre></div>
<p><strong>请求字节数判断</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">   Check if a request is so large that it would wrap around zero when</span>
<span class="cm">   padded and aligned. To simplify some other code, the bound is made</span>
<span class="cm">   low enough so that adding MINSIZE will also not wrap around zero.</span>
<span class="cm"> */</span>

<span class="cp">#define REQUEST_OUT_OF_RANGE(req)                                              \</span>
<span class="cp">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span>
</code></pre></div>
<p><strong>将用户请求内存大小转为实际分配内存大小</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* pad request bytes into a usable size -- internal version */</span>
<span class="c1">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span>
<span class="cp">#define request2size(req)                                                      \</span>
<span class="cp">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span>
<span class="cp">         ? MINSIZE                                                             \</span>
<span class="cp">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span>

<span class="cm">/*  Same, except also perform argument check */</span>

<span class="cp">#define checked_request2size(req, sz)                                          \</span>
<span class="cp">    if (REQUEST_OUT_OF_RANGE(req)) {                                           \</span>
<span class="cp">        __set_errno(ENOMEM);                                                   \</span>
<span class="cp">        return 0;                                                              \</span>
<span class="cp">    }                                                                          \</span>
<span class="cp">    (sz) = request2size(req);</span>
</code></pre></div>
<p>当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</p>
<ol>
<li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li>
<li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li>
<li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配 MINSIZE 字节。</li>
<li>如果大于的话，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要加上 MALLOC_ALIGN_MASK 以便于对齐。</li>
</ol>
<p><strong>个人认为，这里在 request2size 的宏的第一行中没有必要加上 MALLOC_ALIGN_MASK。</strong></p>
<p><strong>需要注意的是，通过这样的计算公式得到的 size 最终一定是满足用户需要的。</strong></p>
<p><strong>标记位相关</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* size field is or&#39;ed with PREV_INUSE when previous adjacent chunk in use */</span>
<span class="cp">#define PREV_INUSE 0x1</span>

<span class="cm">/* extract inuse bit of previous chunk */</span>
<span class="cp">#define prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span>

<span class="cm">/* size field is or&#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
<span class="cp">#define IS_MMAPPED 0x2</span>

<span class="cm">/* check for mmap()&#39;ed chunk */</span>
<span class="cp">#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span>

<span class="cm">/* size field is or&#39;ed with NON_MAIN_ARENA if the chunk was obtained</span>
<span class="cm">   from a non-main arena.  This is only set immediately before handing</span>
<span class="cm">   the chunk to the user, if necessary.  */</span>
<span class="cp">#define NON_MAIN_ARENA 0x4</span>

<span class="cm">/* Check for chunk from main arena.  */</span>
<span class="cp">#define chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span>

<span class="cm">/* Mark a chunk as not being on the main arena.  */</span>
<span class="cp">#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span>

<span class="cm">/*</span>
<span class="cm">   Bits to mask off when extracting size</span>
<span class="cm">   Note: IS_MMAPPED is intentionally not masked off from size field in</span>
<span class="cm">   macros for which mmapped chunks should never be seen. This should</span>
<span class="cm">   cause helpful core dumps to occur if it is tried by accident by</span>
<span class="cm">   people extending or adapting this malloc.</span>
<span class="cm"> */</span>
<span class="cp">#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span>
</code></pre></div>
<p><strong>获取 chunk size</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Get size, ignoring use bits */</span>
<span class="cp">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span>

<span class="cm">/* Like chunksize, but do not mask SIZE_BITS.  */</span>
<span class="cp">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span>
</code></pre></div>
<p><strong>获取下一个物理相邻的 chunk</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Ptr to next physical malloc_chunk. */</span>
<span class="cp">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span>
</code></pre></div>
<p><strong>获取前一个 chunk 的信息</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span>
<span class="cp">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span>

<span class="cm">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span>
<span class="cp">#define set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span>

<span class="cm">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span>
<span class="cp">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span>
</code></pre></div>
<p><strong>当前 chunk 使用状态相关操作</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* extract p&#39;s inuse bit */</span>
<span class="cp">#define inuse(p)                                                               \</span>
<span class="cp">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span>

<span class="cm">/* set/clear chunk as being inuse without otherwise disturbing */</span>
<span class="cp">#define set_inuse(p)                                                           \</span>
<span class="cp">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span>

<span class="cp">#define clear_inuse(p)                                                         \</span>
<span class="cp">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span>
</code></pre></div>
<p><strong>设置 chunk 的 size 字段</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Set size at head, without disturbing its use bit */</span>
<span class="c1">// SIZE_BITS = 7</span>
<span class="cp">#define set_head_size(p, s)                                                    \</span>
<span class="cp">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span>

<span class="cm">/* Set size/use field */</span>
<span class="cp">#define set_head(p, s) ((p)-&gt;mchunk_size = (s))</span>

<span class="cm">/* Set size at footer (only when chunk is not in use) */</span>
<span class="cp">#define set_foot(p, s)                                                         \</span>
<span class="cp">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span>
</code></pre></div>
<p><strong>获取指定偏移的 chunk</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Treat space at ptr + offset as a chunk */</span>
<span class="cp">#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span>
</code></pre></div>
<p><strong>指定偏移处 chunk 使用状态相关操作</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/* check/set/clear inuse bits in known places */</span>
<span class="cp">#define inuse_bit_at_offset(p, s)                                              \</span>
<span class="cp">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span>

<span class="cp">#define set_inuse_bit_at_offset(p, s)                                          \</span>
<span class="cp">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span>

<span class="cp">#define clear_inuse_bit_at_offset(p, s)                                        \</span>
<span class="cp">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span>
</code></pre></div>
<h3 id="bin">bin 介绍<a class="headerlink" href="#bin" title="Permanent link">&para;</a></h3>
<h4 id="_11">概述<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双（单）向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk 。</p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define NBINS 128</span>
<span class="cm">/* Normal bins packed as described above */</span>
<span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span> <span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">];</span>
</code></pre></div>
<p>一个 bin 相当于一个 chunk 链表，我们把每个链表的头节点 chunk 作为 bins 数组，但是由于这个头节点作为 bin 表头，其 prev_size 与 size 字段是没有任何实际作用的，因此我们在存储头节点 chunk 的时候仅仅只需要存储头节点 chunk 的 fd 和 bk 即可，而其中的 prev_size 与 size 字段被重用为另一个 bin 的头节点的 fd 与 bk，这样可以节省空间，并提高可用性。因此**我们仅仅只需要 mchunkptr 类型的指针数组就足够存储这些头节点**，那 prev_size 与 size 字段到底是怎么重用的呢？这里我们以 32 位系统为例</p>
<table>
<thead>
<tr>
<th align="left">含义</th>
<th align="left">bin1 的 fd/bin2 的 prev_size</th>
<th align="left">bin1 的 bk/bin2 的 size</th>
<th align="left">bin2 的 fd/bin3 的 prev_size</th>
<th align="left">bin2 的 bk/bin3 的 size</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">bin 下标</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
</tbody>
</table>
<p>可以看出除了第一个 bin（unsorted bin）外，后面的每个 bin 的表头 chunk 会重用前面的 bin 表头 chunk 的 fd 与 bk 字段，将其视为其自身的 prev_size 和 size 字段。这里也说明了一个问题，<strong>bin 的下标和我们所说的第几个 bin 并不是一致的。同时，bin 表头的 chunk 头节点 的 prev_size 与 size 字段不能随便修改，因为这两个字段是其它 bin 表头 chunk 的 fd 和 bk 字段。</strong></p>
<p>数组中的 bin 依次介绍如下</p>
<ol>
<li>（索引）第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
</ol>
<blockquote>
<p>在 <code>glibc</code> 中用于记录 <em>bin</em> 的数据结构有两种，分别为：</p>
<ul>
<li><code>fastbinsY</code>: 这是一个数组，用于记录所有的 <em>fast bin</em></li>
<li><code>bin</code> 数组: 这也是一个数组，用于记录除 <em>fast bin</em> 之外的所有 <em>bin</em> 。事实上这个数组共有 126 个元素，分别是:</li>
<li><code>[1]</code> 为 <em>unsorted bin</em></li>
<li><code>[2~63]</code> 为 <em>small bin</em></li>
<li><code>[64~126]</code> 为 <em>large bin</em></li>
</ul>
<p>回顾 <code>malloc_chunk</code> 的数据结构，其中的 <code>fd</code> 和 <code>bk</code> 指针就是指向当前 <em>chunk</em> 所属的链表中 <code>forward chunk</code> 或者 <code>backward chunk</code>，<strong>因此一般的 bin 是一个双向链表</strong>（有例外）。</p>
</blockquote>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先**放到 fast bins 的容器内。**而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<p>bin 通用的宏如下</p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">malloc_chunk</span> <span class="o">*</span><span class="n">mbinptr</span><span class="p">;</span>

<span class="cm">/* addressing -- note that bin_at(0) does not exist */</span>
<span class="cp">#define bin_at(m, i)                                                           \</span>
<span class="cp">    (mbinptr)(((char *) &amp;((m)-&gt;bins[ ((i) -1) * 2 ])) -                        \</span>
<span class="cp">              offsetof(struct malloc_chunk, fd))</span>

<span class="cm">/* analog of ++bin */</span>
<span class="c1">//获取下一个bin的地址</span>
<span class="cp">#define next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span>

<span class="cm">/* Reminders about list directionality within bins */</span>
<span class="c1">// 这两个宏可以用来遍历bin</span>
<span class="c1">// 获取 bin 的位于链表头的 chunk</span>
<span class="cp">#define first(b) ((b)-&gt;fd)</span>
<span class="c1">// 获取 bin 的位于链表尾的 chunk</span>
<span class="cp">#define last(b) ((b)-&gt;bk)</span>
</code></pre></div>
<h4 id="fast-bin">Fast Bin<a class="headerlink" href="#fast-bin" title="Permanent link">&para;</a></h4>
<p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。**因为我们把大部分时间花在了合并、分割以及中间检查的过程中。**因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">   Fastbins</span>

<span class="cm">    An array of lists holding recently freed small chunks.  Fastbins</span>
<span class="cm">    are not doubly linked.  It is faster to single-link them, and</span>
<span class="cm">    since chunks are never removed from the middles of these lists,</span>
<span class="cm">    double linking is not necessary. Also, unlike regular bins, they</span>
<span class="cm">    are not even processed in FIFO order (they use faster LIFO) since</span>
<span class="cm">    ordering doesn&#39;t much matter in the transient contexts in which</span>
<span class="cm">    fastbins are normally used.</span>

<span class="cm">    Chunks in fastbins keep their inuse bit set, so they cannot</span>
<span class="cm">    be consolidated with other free chunks. malloc_consolidate</span>
<span class="cm">    releases all chunks in fastbins and consolidates them with</span>
<span class="cm">    other free chunks.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">malloc_chunk</span> <span class="o">*</span><span class="n">mfastbinptr</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">    This is in malloc_state.</span>
<span class="cm">    /* Fastbins */</span>
    <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span> <span class="n">NFASTBINS</span> <span class="p">];</span>
<span class="err">*/</span>
</code></pre></div>
<p>为了更加高效地利用 fast bin，glibc 采用**单向链表**对其中的每个 bin 进行组织(只使用 <code>fd</code> 指针)，并且**每个 bin 采取 LIFO 策略（后进先出）**，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p>
<blockquote>
<p><em>fast bin</em> 中无论是添加还是移除 <em>fast chunk</em>，都是对“链表尾”进行操作，而不会对某个中间的 <em>fast chunk</em> 进行操作。</p>
</blockquote>
<p><img alt="fast bin" src="img\fast-bin.png" /></p>
<p>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， <strong>fastbin 最多可以支持的 bin 的个数为 10 个</strong>，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）定义如下：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span>

<span class="cp">#ifndef DEFAULT_MXFAST</span>
<span class="cp">#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span>
<span class="cp">#endif</span>

<span class="cm">/* The maximum fastbin request size we support */</span>
<span class="cp">#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span>

<span class="cm">/*</span>
<span class="cm">   Since the lowest 2 bits in max_fast don&#39;t matter in size comparisons,</span>
<span class="cm">   they are used as flags.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span>
<span class="cm">   some fastbin chunks. It is set true on entering a chunk into any</span>
<span class="cm">   fastbin, and cleared only in malloc_consolidate.</span>

<span class="cm">   The truth value is inverted so that have_fastchunks will be true</span>
<span class="cm">   upon startup (since statics are zero-filled), simplifying</span>
<span class="cm">   initialization checks.</span>
<span class="cm"> */</span>
<span class="c1">//判断分配区是否有 fast bin chunk，1表示没有</span>
<span class="cp">#define FASTCHUNKS_BIT (1U)</span>

<span class="cp">#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span>
<span class="cp">#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span>
<span class="cp">#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span>

<span class="cm">/*</span>
<span class="cm">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span>
<span class="cm">   regions.  Otherwise, contiguity is exploited in merging together,</span>
<span class="cm">   when possible, results from consecutive MORECORE calls.</span>

<span class="cm">   The initial value comes from MORECORE_CONTIGUOUS, but is</span>
<span class="cm">   changed dynamically if mmap is ever used as an sbrk substitute.</span>
<span class="cm"> */</span>
<span class="c1">// MORECORE是否返回连续的内存区域。</span>
<span class="c1">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span>
<span class="c1">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span>
<span class="c1">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span>
<span class="cp">#define NONCONTIGUOUS_BIT (2U)</span>

<span class="cp">#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span>
<span class="cp">#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span>
<span class="cp">#define set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span>
<span class="cp">#define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span>

<span class="cm">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span>
<span class="cm">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span>
<span class="cm">   allocated in that arena before detecting corruption are not freed.  */</span>

<span class="cp">#define ARENA_CORRUPTION_BIT (4U)</span>

<span class="cp">#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span>
<span class="cp">#define set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span>

<span class="cm">/*</span>
<span class="cm">   Set value of max_fast.</span>
<span class="cm">   Use impossibly small value if 0.</span>
<span class="cm">   Precondition: there are no existing fastbin chunks.</span>
<span class="cm">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span>
<span class="cm"> */</span>

<span class="cp">#define set_max_fast(s)                                                        \</span>
<span class="cp">    global_max_fast =                                                          \</span>
<span class="cp">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span>
<span class="cp">#define get_max_fast() global_max_fast</span>
</code></pre></div>
<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p>
<blockquote>
<p>那么 <code>malloc</code> 操作具体如何处理 <em>fast chunk</em> 呢？</p>
<p>当用户通过 <code>malloc</code> 请求的大小属于 <em>fast chunk</em> 的大小范围（注意：用户请求 size 加上 16 字节就是实际内存 <em>chunk size</em>）。在初始化的时候 <em>fast bin</em> 支持的最大内存大小以及所有 <em>fast bin</em> 链表都是空的，所以当最开始使用 <code>malloc</code> 申请内存的时候，即使申请的内存大小属于 <em>fast chunk</em> 的内存大小（即 16 到 80 字节），它也不会交由 <em>fast bin</em> 来处理，而是向下传递交由 <em>small bin</em> 来处理，如果 <em>small bin</em> 也为空的话就交给 <em>unsorted bin</em> 处理。那么 <em>fast bin</em> 是在哪？怎么进行初始化的呢？</p>
<p>当我们第一次调用 <code>malloc</code> 的时候，系统执行 <code>_int_malloc</code> 函数，该函数首先会发现当前 <em>fast bin</em> 为空，就转交给 <em>small bin</em> 处理，进而又发现 <em>small bin</em> 也为空，就调用 <code>malloc_consolidate</code> 函数对 <code>malloc_state</code> 结构体进行初始化，<code>malloc_consolidate</code> 函数主要完成以下几个功能：</p>
<ul>
<li>首先判断当前 <code>malloc_state</code> 结构体中的 <em>fast bin</em> 是否为空，如果为空就说明整个 <code>malloc_state</code> （<em>arena</em>）都没有完成初始化，需要对 <code>malloc_state</code> 进行初始化。</li>
<li><code>malloc_state</code> 的初始化操作由函数 <code>malloc_init_state(av)</code> 完成，该函数先初始化除 <em>fast bin</em> 之外的所有的 <em>bin</em> (构建双链表，详情见后文<code>small bins</code>介绍)，再初始化 <em>fast bins</em>。</li>
<li>当再次执行 <code>malloc</code> 函数的时候，此时 <em>fast bin</em> 相关数据不为空了，就开始使用 <em>fast bin</em>，这部分代码如下：</li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="n">_int_malloc</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// …</span>
  <span class="cm">/*</span>
<span class="cm">     If the size qualifies as a fastbin, first check corresponding bin.</span>
<span class="cm">     This code is safe to execute even if av is not yet initialized, so we</span>
<span class="cm">     can try it without checking, which saves some time on this fast path.</span>
<span class="cm">   */</span>

   <span class="c1">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span>

   <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">get_max_fast</span> <span class="p">()))</span>
    <span class="p">{</span>
      <span class="c1">// use fast bin</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>     
      <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
      <span class="n">mchunkptr</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
      <span class="k">do</span>
        <span class="p">{</span>
          <span class="n">victim</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

      <span class="c1">// remove chunk from fast bin    </span>
      <span class="k">while</span> <span class="p">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_acq</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">victim</span><span class="p">))</span><span class="o">!=</span> <span class="n">victim</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fastbin_index</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
              <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;malloc(): memory corruption (fast)&quot;</span><span class="p">;</span>
            <span class="nl">errout</span><span class="p">:</span>
              <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">));</span>
              <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="n">check_remalloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
          <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
          <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<blockquote>
<p>得到第一个来自于 <em>fast bin</em> 的 <em>chunk</em> 之后，系统就将该 <em>chunk</em> 从对应的 <em>fast bin</em> 中移除，并将其地址返回给用户。</p>
</blockquote>
<p><strong>fastbin 的索引</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span>

<span class="cm">/* offset 2 to use otherwise unindexable first 2 bins */</span>
<span class="c1">// chunk size=2*size_sz*(2+idx)</span>
<span class="c1">// 这里要减2，否则的话，前两个bin没有办法索引到。</span>
<span class="cp">#define fastbin_index(sz)                                                      \</span>
<span class="cp">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span>
</code></pre></div>
<p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p>
<p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span>
<span class="cm">   that triggers automatic consolidation of possibly-surrounding</span>
<span class="cm">   fastbin chunks. This is a heuristic, so the exact value should not</span>
<span class="cm">   matter too much. It is defined at half the default trim threshold as a</span>
<span class="cm">   compromise heuristic to only attempt consolidation if it is likely</span>
<span class="cm">   to lead to trimming. However, it is not dynamically tunable, since</span>
<span class="cm">   consolidation reduces fragmentation surrounding large chunks even</span>
<span class="cm">   if trimming is not used.</span>
<span class="cm"> */</span>

<span class="cp">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span>
</code></pre></div>
<p><strong>malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。具体地参见后续的详细函数的分析。</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">    Chunks in fastbins keep their inuse bit set, so they cannot</span>
<span class="cm">    be consolidated with other free chunks. malloc_consolidate</span>
<span class="cm">    releases all chunks in fastbins and consolidates them with</span>
<span class="cm">    other free chunks.</span>
<span class="cm"> */</span>
</code></pre></div>
<h4 id="small-bin">Small Bin<a class="headerlink" href="#small-bin" title="Permanent link">&para;</a></h4>
<p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th align="center">下标</th>
<th align="center">SIZE_SZ=4（32 位）</th>
<th align="center">SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">2</td>
<td align="center">16</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">24</td>
<td align="center">48</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">40</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">2*4*x</td>
<td align="center">2*8*x</td>
</tr>
<tr>
<td align="center">63</td>
<td align="center">504</td>
<td align="center">1008</td>
</tr>
</tbody>
</table>
<p>small bins 中一共有 62 个**循环双向链表，每个链表中存储的 chunk 大小都一致**。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>（先进先出），所以同一个链表中先被释放的 chunk 会先被分配出去。<strong>物理地址相邻的 <em>free chunk</em> 需要进行合并操作，即合并成一个大的 <em>free chunk</em></strong> 。</p>
<blockquote>
<p>当释放 <em>small chunk</em> 的时候，先检查该 <em>chunk</em> 相邻的 <em>chunk</em> 是否为 <em>free chunk</em>，如果是的话就进行合并操作：将这些 <em>chunk</em> 合并成新的 <em>chunk</em> ，然后将它们从 <em>small bin</em> 中移除，最后将新的 <em>chunk</em> 添加到 <em>unsorted bin</em> 中。</p>
</blockquote>
<p>small bin 相关的宏如下</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define NSMALLBINS 64</span>
<span class="cp">#define SMALLBIN_WIDTH MALLOC_ALIGNMENT</span>
<span class="c1">// 是否需要对small bin的下标进行纠正</span>
<span class="cp">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span>

<span class="cp">#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span>
<span class="c1">//判断chunk的大小是否在small bin范围内</span>
<span class="cp">#define in_smallbin_range(sz)                                                  \</span>
<span class="cp">    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span>
<span class="c1">// 根据chunk的大小得到small bin对应的索引。</span>
<span class="cp">#define smallbin_index(sz)                                                     \</span>
<span class="cp">    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \</span>
<span class="cp">                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \</span>
<span class="cp">     SMALLBIN_CORRECTION)</span>
</code></pre></div>
<p><strong>或许，大家会很疑惑，那 fastbin 与 small bin 中 chunk 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 chunk 是有可能被放到 small bin 中去的，我们在后面分析具体的源代码时会有深刻的体会。</p>
<h4 id="large-bin">Large Bin<a class="headerlink" href="#large-bin" title="Permanent link">&para;</a></h4>
<p>large bins 中一共包括 63 个 bin，<strong>每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内</strong>。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="left">数量</th>
<th align="left">公差</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">1</td>
<td align="left">32</td>
<td align="left">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">16</td>
<td align="left">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">不限制</td>
</tr>
</tbody>
</table>
<p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p>
<p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为 56+8=64。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define largebin_index_32(sz)                                                  \</span>
<span class="cp">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \</span>
<span class="cp">         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span>
<span class="cp">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span>
<span class="cp">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span>
<span class="cp">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span>
<span class="cp">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span>
<span class="cp">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span>
<span class="cp">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span>
<span class="cp">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span>
<span class="cp">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span>
<span class="cp">                                 : 126)</span>

<span class="cp">#define largebin_index_32_big(sz)                                              \</span>
<span class="cp">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \</span>
<span class="cp">         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span>
<span class="cp">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span>
<span class="cp">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span>
<span class="cp">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span>
<span class="cp">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span>
<span class="cp">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span>
<span class="cp">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span>
<span class="cp">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span>
<span class="cp">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span>
<span class="cp">                                 : 126)</span>

<span class="c1">// XXX It remains to be seen whether it is good to keep the widths of</span>
<span class="c1">// XXX the buckets the same or whether it should be scaled by a factor</span>
<span class="c1">// XXX of two as well.</span>
<span class="cp">#define largebin_index_64(sz)                                                  \</span>
<span class="cp">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \</span>
<span class="cp">         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span>
<span class="cp">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span>
<span class="cp">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span>
<span class="cp">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span>
<span class="cp">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span>
<span class="cp">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span>
<span class="cp">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span>
<span class="cp">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span>
<span class="cp">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span>
<span class="cp">                                 : 126)</span>

<span class="cp">#define largebin_index(sz)                                                     \</span>
<span class="cp">    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \</span>
<span class="cp">                                                ? largebin_index_32_big(sz)    \</span>
<span class="cp">                                                : largebin_index_32(sz))</span>
</code></pre></div>
<ul>
<li>
<p><em>large chunk</em> 可以添加、删除在 <em>large bin</em> 的任何一个位置。</p>
</li>
<li>
<p>鉴于同一个 <em>large bin</em> 中每个 <em>chunk</em> 的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个 <em>large bin</em> 中的所有 <em>chunk</em> 按照 <em>chunk size</em> 进行从大到小的排列：最大的 <em>chunk</em> 放在链表的前端，最小的 <em>chunk</em> 放在尾端。</p>
</li>
<li>
<p><em>large bin</em> 的 <code>free</code> （合并）操作类似于 <em>small bin</em>。</p>
</li>
<li>
<p><em>large bin</em> malloc （部分）操作：</p>
</li>
</ul>
<p>如果尾端最小的 <em>chunk</em> 大于用户请求的大小的话，就将该 <em>chunk</em> 拆分为两个 <em>chunk</em>：前者返回给用户，大小等同于用户请求的大小；剩余的部分做为一个新的 <em>chunk</em> 添加到 <em>unsorted bin</em> 中。</p>
<h4 id="unsorted-bin">Unsorted Bin<a class="headerlink" href="#unsorted-bin" title="Permanent link">&para;</a></h4>
<p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>其在 glibc 中具体的说明如下</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">   Unsorted chunks</span>

<span class="cm">    All remainders from chunk splits, as well as all returned chunks,</span>
<span class="cm">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span>
<span class="cm">    in regular bins after malloc gives them ONE chance to be used before</span>
<span class="cm">    binning. So, basically, the unsorted_chunks list acts as a queue,</span>
<span class="cm">    with chunks being placed on it in free (and malloc_consolidate),</span>
<span class="cm">    and taken off (to be either used or placed in bins) in malloc.</span>

<span class="cm">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span>
<span class="cm">    does not have to be taken into account in size comparisons.</span>
<span class="cm"> */</span>
</code></pre></div>
<p>从下面的宏我们可以看出</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span>
<span class="cp">#define unsorted_chunks(M) (bin_at(M, 1))</span>
</code></pre></div>
<p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考上面的介绍。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
<p>下面附上各类上述三类 <em>bin</em> 的逻辑：</p>
<p><img alt="unsorted-small-large-bin" src="img\unsorted-small-large-bin.jpg" /></p>
<h4 id="common-macro">common macro<a class="headerlink" href="#common-macro" title="Permanent link">&para;</a></h4>
<p>这里介绍一些通用的宏</p>
<p><strong>根据 chunk 的大小统一地获得 chunk 所在的索引</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#define bin_index(sz)                                                          \</span>
<span class="cp">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span>
</code></pre></div>
<h2 id="_12">参考资料<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p><a href="https://murphypei.github.io/blog/2019/01/linux-heap">Linux 堆内存管理深入分析</a></p>
</li>
<li>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux">CTF-WIKI</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/AliMobileSecurity/article/details/51384912">Linux堆内存管理深入分析(上半部)</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/AliMobileSecurity/article/details/51481718">Linux堆内存管理深入分析(下半部)</a></p>
</li>
<li>
<p><a href="https://blog.lao-yuan.com/2018/05/29/Linux下堆栈结构分析.html">Linux下堆栈结构分析</a></p>
</li>
</ul>
<h1 id="_13">基础操作<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h1>
<blockquote>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="unlink">unlink<a class="headerlink" href="#unlink" title="Permanent link">&para;</a></h2>
<p>unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</p>
<ul>
<li>
<p>malloc</p>
</li>
<li>
<p>从恰好大小合适的 large bin 中获取 chunk。</p>
<ul>
<li>
<p><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink<sup id="fnref3:1"><a class="footnote-ref" href="#fn:1">1</a></sup>，这就是为什么漏洞会经常出现在它们这里的原因。</strong></p>
</li>
<li>
<p>依次**遍历处理** unsorted bin 时也没有使用 unlink 。</p>
</li>
</ul>
</li>
<li>
<p>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</p>
</li>
<li>
<p>free</p>
</li>
<li>
<p>后向合并，合并物理相邻低地址空闲 chunk。</p>
</li>
<li>
<p>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</p>
</li>
<li>
<p>malloc_consolidate</p>
</li>
<li>
<p>后向合并，合并物理相邻低地址空闲 chunk。</p>
</li>
<li>
<p>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</p>
</li>
<li>
<p>realloc</p>
</li>
<li>
<p>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</p>
</li>
</ul>
<p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Take a chunk off a bin list */</span>
<span class="c1">// unlink p</span>
<span class="cp">#define unlink(AV, P, BK, FD) {                                            \</span>
<span class="cp">    </span><span class="c1">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">next_chunk</span><span class="p">(</span><span class="n">P</span><span class="p">)),</span> <span class="mi">0</span><span class="p">))</span>      \
      <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">&quot;corrupted size vs. prev_size&quot;</span><span class="p">);</span>               \
    <span class="n">FD</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>                                                                      \
    <span class="n">BK</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>                                                                      \
    <span class="c1">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">P</span> <span class="o">||</span> <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                      \
      <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s">&quot;corrupted double-linked list&quot;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>  \
    <span class="k">else</span> <span class="p">{</span>                                                                      \
        <span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">BK</span><span class="p">;</span>                                                              \
        <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">FD</span><span class="p">;</span>                                                              \
        <span class="c1">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">P</span><span class="p">))</span>                              \
            <span class="c1">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span>
            <span class="c1">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span>
            <span class="c1">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span>
            <span class="o">&amp;&amp;</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>                      \
            <span class="c1">// 类似于小的 chunk 的检查思路</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>              \
                <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>    \
              <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span>                                      \
                               <span class="s">&quot;corrupted double-linked list (not small)&quot;</span><span class="p">,</span>    \
                               <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>                                              \
            <span class="c1">// 这里说明 P 已经在 nextsize 链表中了。</span>
            <span class="c1">// 如果 FD 没有在 nextsize 链表中</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">FD</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>                                      \
                <span class="c1">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span>
                <span class="c1">// 令 FD 为 nextsize 串起来的</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">==</span> <span class="n">P</span><span class="p">)</span>                                      \
                  <span class="n">FD</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">FD</span><span class="p">;</span>                      \
                <span class="k">else</span> <span class="p">{</span>                                                              \
                <span class="c1">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span>
                    <span class="n">FD</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>                              \
                    <span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>                              \
                    <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">FD</span><span class="p">;</span>                              \
                    <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">FD</span><span class="p">;</span>                              \
                  <span class="p">}</span>                                                              \
              <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                                              \
                <span class="c1">// 如果在的话，直接拿走即可</span>
                <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>                      \
                <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>                      \
              <span class="p">}</span>                                                                      \
          <span class="p">}</span>                                                                      \
      <span class="p">}</span>                                                                              \
<span class="p">}</span>
</code></pre></div>
<p>这里我们以 small bin 的 unlink 为例子介绍一下。对于 large bin 的 unlink，与其类似，只是多了一个 nextsize 的处理。</p>
<p><img alt="img" src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/figure/unlink_smallbin_intro.png" /></p>
<p>可以看出， <strong>P 最后的 fd 和 bk 指针并没有发生变化</strong>，但是当我们去遍历整个双向链表时，已经遍历不到对应的链表了。这一点没有变化还是很有用处的，因为我们有时候可以使用这个方法来泄漏地址</p>
<ul>
<li>libc 地址</li>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>泄漏堆地址，双向链表包含多个空闲 chunk</li>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li>
<li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li>
</ul>
<p>同时，无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都会检测 fd 和 bk 是否满足对应的要求。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// fd bk</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">P</span> <span class="o">||</span> <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                      \
  <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s">&quot;corrupted double-linked list&quot;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>  \

  <span class="c1">// next_size related</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>              \
                <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>    \
              <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span>                                      \
                               <span class="s">&quot;corrupted double-linked list (not small)&quot;</span><span class="p">,</span>    \
                               <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>
</code></pre></div>
<p>看起来似乎很正常。我们以 fd 和 bk 为例，P 的 forward chunk 的 bk 很自然是 P ，同样 P 的 backward chunk 的 fd 也很自然是 P 。如果没有做相应的检查的话，我们可以修改 P 的 fd 与 bk，从而可以很容易地达到任意地址写的效果。关于更加详细的例子，可以参见利用部分的 unlink 。</p>
<p><strong>注意：堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></p>
<h2 id="malloc_printerr">malloc_printerr<a class="headerlink" href="#malloc_printerr" title="Permanent link">&para;</a></h2>
<p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">malloc_printerr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__libc_message</span><span class="p">(</span><span class="n">do_abort</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
  <span class="n">__builtin_unreachable</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>主要会调用 <code>__libc_message</code> 来执行<code>abort</code> 函数，如下</p>
<div class="highlight"><pre><span></span><code>  <span class="k">if</span> <span class="p">((</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">do_abort</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">do_backtrace</span><span class="p">))</span>
      <span class="n">BEFORE_ABORT</span><span class="p">(</span><span class="n">do_abort</span><span class="p">,</span> <span class="n">written</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Kill the application.  */</span>
    <span class="n">abort</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div>
<p>在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream。</p>
<div class="highlight"><pre><span></span><code>  <span class="cm">/* Flush all streams.  We cannot close them now because the user</span>
<span class="cm">     might have registered a handler for SIGABRT.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stage</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">++</span><span class="n">stage</span><span class="p">;</span>
      <span class="n">fflush</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<h1 id="_14">申请内存块<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Allocate Heap Memory</p>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="__libc_malloc">__libc_malloc<a class="headerlink" href="#__libc_malloc" title="Permanent link">&para;</a></h2>
<p>一般我们会使用 malloc 函数来申请内存块，可是当仔细看 glibc 的源码实现时，其实并没有 malloc 函数。其实该函数真正调用的是 __libc_malloc 函数。为什么不直接写个 malloc 函数呢，因为有时候我们可能需要不同的名称。此外，__libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下具体的实现。</p>
<p>该函数会**首先检查是否有内存分配函数的钩子函数（__malloc_hook）<strong>，这个主要用于用户自定义的堆分配函数，方便用户快速修改堆分配函数并进行测试。这里需要注意的是，**用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// wapper for int_malloc</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__libc_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span><span class="c1">//size_t 为当前程序位数最长的无符号int型</span>
    <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">victim</span><span class="p">;</span>
    <span class="c1">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span><span class="p">(</span><span class="n">__malloc_hook</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="c1">//钩子不为空</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="c1">//调用钩子并返回</span>
</code></pre></div>
<p>接着会寻找一个 arena 来试图分配内存。</p>
<div class="highlight"><pre><span></span><code>    arena_get(ar_ptr, bytes);
</code></pre></div>
<p>然后调用 _int_malloc 函数去申请对应的内存。</p>
<div class="highlight"><pre><span></span><code>    victim = _int_malloc(ar_ptr, bytes);
</code></pre></div>
<p>如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存。</p>
<div class="highlight"><pre><span></span><code>    /* Retry with another arena only if we were able to find a usable arena
       before.  */
    if (!victim &amp;&amp; ar_ptr != NULL) {
        LIBC_PROBE(memory_malloc_retry, 1, bytes);
        ar_ptr = arena_get_retry(ar_ptr, bytes);
        victim = _int_malloc(ar_ptr, bytes);
    }
</code></pre></div>
<p>如果申请到了 arena，那么在退出之前还得解锁。</p>
<div class="highlight"><pre><span></span><code>    if (ar_ptr != NULL) __libc_lock_unlock(ar_ptr-&gt;mutex);
</code></pre></div>
<p>判断目前的状态是否满足以下条件</p>
<ul>
<li>要么没有申请到内存</li>
<li>要么是 mmap 的内存</li>
<li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li>
</ul>
<div class="highlight"><pre><span></span><code>    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||
           ar_ptr == arena_for_chunk(mem2chunk(victim)));
</code></pre></div>
<p>最后返回内存。</p>
<div class="highlight"><pre><span></span><code>    return victim;
}
</code></pre></div>
<h2 id="_int_malloc">_int_malloc<a class="headerlink" href="#_int_malloc" title="Permanent link">&para;</a></h2>
<p>_int_malloc 是内存分配的核心函数，其核心思路有如下</p>
<ol>
<li>它根据用户申请的**内存块大小**以及**相应大小 chunk 通常使用的频度**（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>
<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>
<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>
<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>
</ol>
<p>在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的 chunk 大小。</p>
<div class="highlight"><pre><span></span><code>static void *_int_malloc(mstate av, size_t bytes) {
    INTERNAL_SIZE_T nb;  /* normalized request size */
    unsigned int    idx; /* associated bin index */
    mbinptr         bin; /* associated bin */

    mchunkptr       victim;       /* inspected/selected chunk */
    INTERNAL_SIZE_T size;         /* its size */
    int             victim_index; /* its bin index */

    mchunkptr     remainder;      /* remainder from a split */
    unsigned long remainder_size; /* its size */

    unsigned int block; /* bit map traverser */
    unsigned int bit;   /* bit map traverser */
    unsigned int map;   /* current word of binmap */

    mchunkptr fwd; /* misc temp for linking */
    mchunkptr bck; /* misc temp for linking */

    const char *errstr = NULL;

    /*
       Convert request size to internal form by adding SIZE_SZ bytes
       overhead plus possibly more to obtain necessary alignment and/or
       to obtain a size of at least MINSIZE, the smallest allocatable
       size. Also, checked_request2size traps (returning 0) request sizes
       that are so large that they wrap around zero when padded and
       aligned.
     */

    checked_request2size(bytes, nb);
</code></pre></div>
<h3 id="arena_2">arena<a class="headerlink" href="#arena_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>    <span class="cm">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span>
<span class="cm">       mmap.  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sysmalloc</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="fast-bin_1">fast bin<a class="headerlink" href="#fast-bin_1" title="Permanent link">&para;</a></h3>
<p>如果申请的 chunk 的大小位于 fastbin 范围内，<strong>需要注意的是这里比较的是无符号整数</strong>。<strong>此外，是从 fastbin 的头结点开始取 chunk</strong>。</p>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">       If the size qualifies as a fastbin, first check corresponding bin.</span>
<span class="cm">       This code is safe to execute even if av is not yet initialized, so we</span>
<span class="cm">       can try it without checking, which saves some time on this fast path.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">get_max_fast</span><span class="p">()))</span> <span class="p">{</span><span class="c1">//申请大小小于等于fastbin上限</span>
        <span class="c1">// 得到对应的fastbin的下标</span>
        <span class="n">idx</span>             <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
        <span class="c1">// 得到对应的fastbin的头指针</span>
        <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span><span class="c1">//单链表</span>
        <span class="n">mchunkptr</span>    <span class="n">pp</span> <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
        <span class="c1">// 利用fd遍历对应的bin内是否有空闲的chunk块，</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">victim</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_acq</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span>
                                                            <span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">);</span>
        <span class="c1">// 存在可以利用的chunk</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span>
            <span class="c1">// 根据取得的 victim ，利用 chunksize 计算其大小。</span>
            <span class="c1">// 利用fastbin_index 计算 chunk 的索引。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">fastbin_index</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;malloc(): memory corruption (fast)&quot;</span><span class="p">;</span>
            <span class="nl">errout</span><span class="p">:</span>
                <span class="n">malloc_printerr</span><span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">),</span> <span class="n">av</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 细致的检查。。只有在 DEBUG 的时候有用</span>
            <span class="n">check_remalloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
            <span class="c1">// 将获取的到chunk转换为mem模式</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
            <span class="c1">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span>
            <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<h4 id="_15">小总结<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<ul>
<li>malloc 参数是无符号长整型</li>
<li>fastbin 是从头结点（最新进入）开始取 chunk ，符合“先进后出”</li>
</ul>
<h5 id="fast-bin-malloc">fast bin malloc 检查机制<a class="headerlink" href="#fast-bin-malloc" title="Permanent link">&para;</a></h5>
<p><strong>不启动 DEBUG 时，只检查即将分配 chunk 对应的 idx 是否与申请时的 idx 一致</strong>，步骤如下：</p>
<ol>
<li><code>chunksize(victim)</code> ：提取 victim size</li>
<li><code>fastbin_index()</code> ：查找 victim size 对应的 idx</li>
<li><code>!= idx</code>：检查是否相等，如果不相等则调用 malloc_printerr 打印错误信息</li>
</ol>
<h3 id="small-bin_1">small bin<a class="headerlink" href="#small-bin_1" title="Permanent link">&para;</a></h3>
<p>如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程</p>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span>
<span class="cm">       hold one size each, no searching within bins is necessary.</span>
<span class="cm">       (For a large request, we need to wait until unsorted chunks are</span>
<span class="cm">       processed to find best fit. But for small ones, fits are exact</span>
<span class="cm">       anyway, so we can check now, which is faster.)</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 获取 small bin 的索引</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
        <span class="c1">// 获取对应 small bin 中的 chunk 指针</span>
        <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="c1">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span>
        <span class="c1">// 如果 victim = bin ，那说明该 bin 为空。</span>
        <span class="c1">// 如果不相等，那么会有两种情况</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">last</span><span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 第一种情况，small bin 还没有初始化。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* initialization check */</span>
                <span class="c1">// 执行初始化，将 fast bins 中的 chunk 进行合并</span>
                <span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
            <span class="c1">// 第二种情况，small bin 中存在空闲的 chunk</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 获取 small bin 中倒数第二个 chunk 。</span>
                <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
                <span class="c1">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;malloc(): smallbin double linked list corrupted&quot;</span><span class="p">;</span>
                    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// 设置 victim 对应的 inuse 位</span>
                <span class="n">set_inuse_bit_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
                <span class="c1">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span>
                <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
                <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>
                <span class="c1">// 如果不是 main_arena，设置对应的标志</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="n">set_non_main_arena</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
                <span class="c1">// 细致的检查，非调试状态没有作用</span>
                <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
                <span class="c1">// 将申请到的 chunk 转化为对应的 mem 状态</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
                <span class="c1">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span>
                <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<h4 id="_16">小总结<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<ul>
<li>malloc 参数是无符号长整型</li>
<li>smallbin 是从最后结点（最先进入）开始取 chunk ，符合“先进先出”</li>
</ul>
<h5 id="small-bin-malloc">small bin malloc 检查机制<a class="headerlink" href="#small-bin-malloc" title="Permanent link">&para;</a></h5>
<p>步骤如下：</p>
<ol>
<li><code>bck = victim-&gt;bk;</code>  |  <code>(bck-&gt;fd != victim)</code> ：检查即将分配的的 victim 的上一个 chunk 的 fd 指针是否指向 victim 防止伪造</li>
<li><code>set_inuse_bit_at_offset(victim, nb);</code> ：修改 victim 的 size inuse 位</li>
<li><code>bin-&gt;bk = bck;</code>  |  <code>bck-&gt;fd = bin;</code> ：修改链表将 victime 取出来（small bin 最后一个）</li>
</ol>
<h3 id="large-bin_1">large bin<a class="headerlink" href="#large-bin_1" title="Permanent link">&para;</a></h3>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是**先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中**，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">       If this is a large request, consolidate fastbins before continuing.</span>
<span class="cm">       While it might look excessive to kill all fastbins before</span>
<span class="cm">       even seeing if there is space available, this avoids</span>
<span class="cm">       fragmentation problems normally associated with fastbins.</span>
<span class="cm">       Also, in practice, programs tend to have runs of either small or</span>
<span class="cm">       large requests, but less often mixtures, so consolidation is not</span>
<span class="cm">       invoked all that often in most programs. And the programs that</span>
<span class="cm">       it is called frequently in otherwise tend to fragment.</span>
<span class="cm">     */</span>

<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 获取large bin的下标。</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">largebin_index</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
    <span class="c1">// 如果存在fastbin的话，会处理 fastbin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">))</span> <span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="-unsorted-bin">大循环 - 遍历 unsorted bin<a class="headerlink" href="#-unsorted-bin" title="Permanent link">&para;</a></h3>
<blockquote>
<p>2020.07.08 largebin 分配机制不太明白</p>
</blockquote>
<p><strong>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk 可以直接满足需求 ，但是 large chunk 则是在这个大循环中处理</strong>。</p>
<p>在接下来的这个循环中，主要做了以下的操作</p>
<ul>
<li><strong>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来</strong></li>
<li>如果是 small request，则考虑是不是恰好满足，是的话，直接返回。</li>
<li>如果不是的话，放到对应的 bin 中。</li>
<li>尝试从 large bin 中分配用户所需的内存</li>
</ul>
<p>该部分是一个大循环，这是为了尝试重新分配 small bin chunk，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以这里会进行 fast bin chunk 的合并，进而使用一个大循环来尝试再次分配 small bin chunk。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">       Process recently freed or remaindered chunks, taking one only if</span>
<span class="cm">       it is exact fit, or, if this a small request, the chunk is remainder from</span>
<span class="cm">       the most recent non-exact fit.  Place other traversed chunks in</span>
<span class="cm">       bins.  Note that this step is the only place in any routine where</span>
<span class="cm">       chunks are placed in bins.</span>

<span class="cm">       The outer loop here is needed because we might not realize until</span>
<span class="cm">       near the end of malloc that we should have consolidated, so must</span>
<span class="cm">       do so and retry. This happens at most once, and only when we would</span>
<span class="cm">       otherwise need to expand memory to service a &quot;small&quot; request.</span>
<span class="cm">     */</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<h4 id="unsorted-bin_1">unsorted bin 遍历<a class="headerlink" href="#unsorted-bin_1" title="Permanent link">&para;</a></h4>
<p>先考虑 unsorted bin，再考虑 last remainder ，但是对于 small bin chunk 的请求会有所例外。</p>
<p><strong>注意 unsorted bin 的遍历顺序为 bk。</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 如果 unsorted bin 不为空</span>
<span class="c1">// First In First Out</span>
<span class="k">while</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// victim 为 unsorted bin 的最后一个 chunk</span>
    <span class="c1">// bck 为 unsorted bin 的倒数第二个 chunk</span>
    <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="c1">// 判断得到的 chunk 是否满足要求，不能过小，也不能过大</span>
    <span class="c1">// 一般 system_mem 的大小为132K</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">victim</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">__builtin_expect</span><span class="p">(</span><span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">victim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">malloc_printerr</span><span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s">&quot;malloc(): memory corruption&quot;</span><span class="p">,</span>
                        <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">),</span> <span class="n">av</span><span class="p">);</span>
    <span class="c1">// 得到victim对应的chunk大小。</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
</code></pre></div>
<h5 id="small-request">SMALL REQUEST<a class="headerlink" href="#small-request" title="Permanent link">&para;</a></h5>
<p>如果用户的请求为 small bin chunk ，那么我们首先考虑 last remainder，如果 last remainder 是 unsorted bin 中的唯一一块的话， 并且 last remainder 的大小分割后还可以作为一个 chunk ，<strong>为什么没有等号</strong>？</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">               If a small request, try to use last remainder if it is the</span>
<span class="cm">               only chunk in unsorted bin.  This helps promote locality for</span>
<span class="cm">               runs of consecutive small requests. This is the only</span>
<span class="cm">               exception to best-fit, and applies only when there is</span>
<span class="cm">               no exact fit for a small chunk.</span>
<span class="cm">               */</span>   
<span class="c1">//是否是smallbin范围；bck是否是链首；remainder是（分配完）剩余部分</span>
<span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bck</span> <span class="o">==</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">victim</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* split and reattach remainder */</span>
    <span class="c1">// 获取新的 remainder 的大小</span>
    <span class="n">remainder_size</span>          <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
    <span class="c1">// 获取新的 remainder 的位置</span>
    <span class="n">remainder</span>               <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="c1">// 更新 unsorted bin 的情况</span>
    <span class="c1">// av是被取出chunk的下一个chunk（fd）</span>
    <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
    <span class="c1">// 更新 av 中记录的 last_remainder</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span>                                <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
    <span class="c1">// 更新last remainder的指针</span>
    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 设置victim的头部，inuse</span>
    <span class="n">set_head</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
             <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// 设置 remainder 的头部</span>
    <span class="n">set_head</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
    <span class="c1">// 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。</span>
    <span class="n">set_foot</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>
    <span class="c1">// 细致的检查，非调试状态下没有作用</span>
    <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="c1">// 将 victim 从 chunk 模式转化为mem模式</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
    <span class="c1">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span>
    <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="_17">初始取出<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><span class="cm">/* remove from unsorted list */</span>
<span class="c1">//修改 unsortedchunk 链表</span>
<span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span>                 <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
</code></pre></div>
<h5 id="chunk-exact-fit">取出 chunk 大小刚好合适 （EXACT FIT）<a class="headerlink" href="#chunk-exact-fit" title="Permanent link">&para;</a></h5>
<p>如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用。这里应该已经把合并后恰好合适的 chunk 给分配出去了。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Take now instead of binning if exact fit */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span><span class="c1">//大小正好合适</span>
    <span class="n">set_inuse_bit_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="c1">// 如果不是 main_arena，设置对应的标志</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="n">set_non_main_arena</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
    <span class="c1">// 细致的检查，非调试状态下没有作用</span>
    <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="c1">// 将 victim 从 chunk 模式转化为mem模式</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
    <span class="c1">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span>
    <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="c1">//直接返回 chunk 指针</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="chunk-smallbin-place-chunk-in-small-bin">将取出来 chunk 放入到 smallbin （PLACE CHUNK IN SMALL BIN）<a class="headerlink" href="#chunk-smallbin-place-chunk-in-small-bin" title="Permanent link">&para;</a></h5>
<p>把取出来的 chunk 放到对应的 small bin 中。</p>
<div class="highlight"><pre><span></span><code>            <span class="cm">/* place chunk in bin */</span>
            <span class="c1">//判断 size 是否在smallbin</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 获取 small bin 的索引</span>
                <span class="n">victim_index</span> <span class="o">=</span> <span class="n">smallbin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
                <span class="c1">// 调整 small bin 的链表</span>
                <span class="n">bck</span>          <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>
                <span class="n">fwd</span>          <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></div>
<h5 id="place-chunk-in-large-bin">PLACE CHUNK IN LARGE BIN<a class="headerlink" href="#place-chunk-in-large-bin" title="Permanent link">&para;</a></h5>
<p>把取出来的 chunk 放到对应的 large bin 中。</p>
<blockquote>
<p>这里应该是获取正确插入位置的指针 bck、fwd。最后插入形式为：bck&harr;victim&harr;fwd。</p>
<p>链表构建在：<a href="# 最终取出">最终取出</a></p>
</blockquote>
<div class="highlight"><pre><span></span><code>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// large bin 范围</span>
                <span class="n">victim_index</span> <span class="o">=</span> <span class="n">largebin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
                <span class="n">bck</span>          <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span> <span class="c1">// 当前 large bin 的头部</span>
                <span class="n">fwd</span>          <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>

                <span class="cm">/* maintain large bins in sorted order */</span>
                <span class="cm">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span>
<span class="cm">                   同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span>
<span class="cm">                   而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span>
<span class="cm">                   可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span>
                <span class="c1">// 如果 large bin 链表不空</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* Or with inuse bit to speed comparisons */</span>
                    <span class="c1">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span>
                    <span class="n">size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span><span class="p">;</span>
                    <span class="cm">/* if smaller than smallest, bypass loop below */</span>
                    <span class="c1">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span>
                    <span class="c1">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span>
                    <span class="c1">// 判断 bck-&gt;bk 是不是在 main arena。</span>
                    <span class="n">assert</span><span class="p">(</span><span class="n">chunk_main_arena</span><span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">));</span>
                    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span>
                        <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">))</span> <span class="p">{</span>
                        <span class="c1">// 令 fwd 指向 large bin 头</span>
                        <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
                        <span class="c1">// 令 bck 指向 largin bin 尾部 chunk</span>
                        <span class="n">bck</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
                        <span class="c1">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span>
                        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
                        <span class="c1">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span>
                        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
                        <span class="c1">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span>
                        <span class="c1">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span>
                        <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span>
                            <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// 当前要插入的 victim 的大小大于最小的 chunk</span>
                        <span class="c1">// 判断 fwd 是否在 main arena</span>
                        <span class="n">assert</span><span class="p">(</span><span class="n">chunk_main_arena</span><span class="p">(</span><span class="n">fwd</span><span class="p">));</span>
                        <span class="c1">// 从链表头部开始找到不比 victim 大的 chunk</span>
                        <span class="k">while</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">fwd</span><span class="p">))</span> <span class="p">{</span>
                            <span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
                            <span class="n">assert</span><span class="p">(</span><span class="n">chunk_main_arena</span><span class="p">(</span><span class="n">fwd</span><span class="p">));</span>
                        <span class="p">}</span>
                        <span class="c1">// 如果找到了一个和 victim 一样大的 chunk，</span>
                        <span class="c1">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span>
                        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">==</span>
                            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">fwd</span><span class="p">))</span>
                            <span class="cm">/* Always insert in the second position.  */</span>
                            <span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
                        <span class="k">else</span> <span class="p">{</span>
                            <span class="c1">// 如果找到的chunk和当前victim大小不一样</span>
                            <span class="c1">// 那么就需要构造 nextsize 双向链表了</span>
                            <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span>              <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
                            <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span>              <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
                            <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span>                 <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
                            <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">bck</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span>
                    <span class="c1">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span>
                    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
            <span class="p">}</span>
</code></pre></div>
<h5 id="_18">最终取出<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>            <span class="c1">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span>
            <span class="n">mark_bin</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>
            <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
            <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
            <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span>    <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
            <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span>    <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
</code></pre></div>
<h5 id="while">WHILE 迭代次数<a class="headerlink" href="#while" title="Permanent link">&para;</a></h5>
<p>while 最多迭代 10000 次后退出。</p>
<div class="highlight"><pre><span></span><code>            <span class="c1">// #define MAX_ITERS 10000</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iters</span> <span class="o">&gt;=</span> <span class="n">MAX_ITERS</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div>
<h4 id="large-chunk">large chunk<a class="headerlink" href="#large-chunk" title="Permanent link">&para;</a></h4>
<p><strong>注： 或许会很奇怪，为什么这里没有先去看 small chunk 是否满足新需求了呢？这是因为 small bin 在循环之前已经判断过了，这里如果有的话，就是合并后的才出现 chunk。但是在大循环外，large chunk 只是单纯地找到其索引，所以觉得在这里直接先判断是合理的，而且也为了下面可以再去找较大的 chunk。</strong></p>
<p>如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。</p>
<div class="highlight"><pre><span></span><code>        <span class="cm">/*</span>
<span class="cm">           If a large request, scan through the chunks of current bin in</span>
<span class="cm">           sorted order to find smallest that fits.  Use the skip list for this.</span>
<span class="cm">         */</span>
        <span class="c1">//判断是否smallbin</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="cm">/* skip scan if empty or largest chunk is too small */</span>
            <span class="c1">// 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过</span>
            <span class="c1">// first(bin)=bin-&gt;fd 表示当前链表中最大的chunk</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">victim</span><span class="p">)</span> <span class="o">&gt;=</span>
                    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span>
                <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">&lt;</span>
                        <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)))</span>
                    <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>

                <span class="cm">/* Avoid removing the first entry for a size so that the skip</span>
<span class="cm">                   list does not have to be rerouted.  */</span>
                <span class="c1">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span>
                <span class="c1">// 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span>
                <span class="c1">//  链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">!=</span> <span class="n">last</span><span class="p">(</span><span class="n">bin</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">victim</span><span class="p">)</span> <span class="o">==</span> <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">))</span>
                    <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
                <span class="c1">// 计算分配后剩余的大小</span>
                <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
                <span class="c1">// 进行unlink（宏操作）</span>
                <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>

                <span class="cm">/* Exhaust */</span>
                <span class="c1">// 剩下的大小不足以当做一个块</span>
                <span class="c1">// 很好奇接下来会怎么办？</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">remainder_size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">set_inuse_bit_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="n">set_non_main_arena</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="cm">/* Split */</span>
                <span class="c1">//  剩下的大小还可以作为一个chunk，进行分割。</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// 获取剩下那部分chunk的指针，称为remainder</span>
                    <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
                    <span class="cm">/* We cannot assume the unsorted list is empty and therefore</span>
<span class="cm">                       have to perform a complete insert here.  */</span>
                    <span class="c1">// 插入unsorted bin中</span>
                    <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
                    <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
                    <span class="c1">// 判断 unsorted bin 是否被破坏。</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;malloc(): corrupted unsorted chunks&quot;</span><span class="p">;</span>
                        <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
                    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
                    <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span>       <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
                    <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span>       <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
                    <span class="c1">// 如果不处于small bin范围内，就设置对应的字段</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">// 设置分配的chunk的标记</span>
                    <span class="n">set_head</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span>
                             <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
                                 <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>

                    <span class="c1">// 设置remainder的上一个chunk，即分配出去的chunk的使用状态</span>
                    <span class="c1">// 其余的不用管，直接从上面继承下来了</span>
                    <span class="n">set_head</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
                    <span class="c1">// 设置remainder的大小</span>
                    <span class="n">set_foot</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">// 检查</span>
                <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
                <span class="c1">// 转换为mem状态</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
                <span class="c1">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span>
                <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>
<h4 id="chunk_2">寻找较大 chunk<a class="headerlink" href="#chunk_2" title="Permanent link">&para;</a></h4>
<p><strong>如果走到了这里，那说明对于用户所需的 chunk，不能直接从其对应的合适的 bin 中获取 chunk</strong><sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">1</a></sup>，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p>
<div class="highlight"><pre><span></span><code>        <span class="cm">/*</span>
<span class="cm">           Search for a chunk by scanning bins, starting with next largest</span>
<span class="cm">           bin. This search is strictly by best-fit; i.e., the smallest</span>
<span class="cm">           (with ties going to approximately the least recently used) chunk</span>
<span class="cm">           that fits is selected.</span>

<span class="cm">           The bitmap avoids needing to check that most blocks are nonempty.</span>
<span class="cm">           The particular case of skipping all bins during warm-up phases</span>
<span class="cm">           when no chunks have been returned yet is faster than it might look.</span>
<span class="cm">         */</span>

        <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
        <span class="c1">// 获取对应的bin</span>
        <span class="n">bin</span>   <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="c1">// 获取当前索引在binmap中的block索引</span>
        <span class="c1">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span>
        <span class="c1">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span>
        <span class="c1">// 所以这里是右移5</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">idx2block</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="c1">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span>
        <span class="n">map</span>   <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">binmap</span><span class="p">[</span> <span class="n">block</span> <span class="p">];</span>
        <span class="c1">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span>
        <span class="c1">// 将idx对应的比特位设置为1，其它位为0</span>
        <span class="n">bit</span>   <span class="o">=</span> <span class="n">idx2bit</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</code></pre></div>
<h5 id="map">找到一个合适的 MAP<a class="headerlink" href="#map" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>            <span class="cm">/* Skip rest of block if there are no more set bits in this block.</span>
<span class="cm">             */</span>
            <span class="c1">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span>
            <span class="c1">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;</span> <span class="n">map</span> <span class="o">||</span> <span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">do</span> <span class="p">{</span>
                    <span class="c1">// 寻找下一个block，直到其对应的map不为0。</span>
                    <span class="c1">// 如果已经不存在的话，那就只能使用top chunk了</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">BINMAPSIZE</span><span class="p">)</span> <span class="cm">/* out of bins */</span>
                        <span class="k">goto</span> <span class="n">use_top</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">map</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">binmap</span><span class="p">[</span> <span class="n">block</span> <span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
                <span class="c1">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span>
                <span class="c1">// map本身不为0，所以必然存在满足需求的chunk。</span>
                <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">BINMAPSHIFT</span><span class="p">));</span>
                <span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
</code></pre></div>
<h5 id="bin_1">找到合适的 BIN<a class="headerlink" href="#bin_1" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>            <span class="cm">/* Advance to bin with set bit. There must be one. */</span>
            <span class="c1">// 从当前map的最小的bin一直找，直到找到合适的bin。</span>
            <span class="c1">// 这里是一定存在的</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">bin</span> <span class="o">=</span> <span class="n">next_bin</span><span class="p">(</span><span class="n">bin</span><span class="p">);</span>
                <span class="n">bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div>
<h5 id="chunk_3">简单检查 CHUNK<a class="headerlink" href="#chunk_3" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>            <span class="cm">/* Inspect the bin. It is likely to be non-empty */</span>
            <span class="c1">// 获取对应的bin</span>
            <span class="n">victim</span> <span class="o">=</span> <span class="n">last</span><span class="p">(</span><span class="n">bin</span><span class="p">);</span>

            <span class="cm">/*  If a false alarm (empty bin), clear the bit. */</span>
            <span class="c1">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span>
            <span class="c1">// 这种情况发生的概率应该很小。</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="n">bin</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">av</span><span class="o">-&gt;</span><span class="n">binmap</span><span class="p">[</span> <span class="n">block</span> <span class="p">]</span> <span class="o">=</span> <span class="n">map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bit</span><span class="p">;</span> <span class="cm">/* Write through */</span>
                <span class="n">bin</span>                 <span class="o">=</span> <span class="n">next_bin</span><span class="p">(</span><span class="n">bin</span><span class="p">);</span>
                <span class="n">bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
</code></pre></div>
<h5 id="chunk_4">真正取出 CHUNK<a class="headerlink" href="#chunk_4" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 获取对应victim的大小</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>

                <span class="cm">/*  We know the first chunk in this bin is big enough to use. */</span>
                <span class="n">assert</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">));</span>
                <span class="c1">// 计算分割后剩余的大小</span>
                <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>

                <span class="cm">/* unlink */</span>
                <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>

                <span class="cm">/* Exhaust */</span>
                <span class="c1">// 如果分割后不够一个chunk怎么办？</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">remainder_size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">set_inuse_bit_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="n">set_non_main_arena</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="cm">/* Split */</span>
                <span class="c1">// 如果够，尽管分割</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// 计算剩余的chunk的偏移</span>
                    <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>

                    <span class="cm">/* We cannot assume the unsorted list is empty and therefore</span>
<span class="cm">                       have to perform a complete insert here.  */</span>
                    <span class="c1">// 将剩余的chunk插入到unsorted bin中</span>
                    <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
                    <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;malloc(): corrupted unsorted chunks 2&quot;</span><span class="p">;</span>
                        <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
                    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
                    <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span>       <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
                    <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span>       <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>

                    <span class="cm">/* advertise as last remainder */</span>
                    <span class="c1">// 如果在small bin范围内，就将其标记为remainder</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">// 设置victim的使用状态</span>
                    <span class="n">set_head</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span>
                             <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
                                 <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
                    <span class="c1">// 设置remainder的使用状态，这里是为什么呢？</span>
                    <span class="n">set_head</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
                    <span class="c1">// 设置remainder的大小</span>
                    <span class="n">set_foot</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">// 检查</span>
                <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
                <span class="c1">// chunk状态转换到mem状态</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
                <span class="c1">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span>
                <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
</code></pre></div>
<h3 id="top-chunk_1">使用 top chunk<a class="headerlink" href="#top-chunk_1" title="Permanent link">&para;</a></h3>
<p>**如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。**那么我们就只能使用 top chunk 了。</p>
<div class="highlight"><pre><span></span><code>    <span class="nl">use_top</span><span class="p">:</span>
        <span class="cm">/*</span>
<span class="cm">           If large enough, split off the chunk bordering the end of memory</span>
<span class="cm">           (held in av-&gt;top). Note that this is in accord with the best-fit</span>
<span class="cm">           search rule.  In effect, av-&gt;top is treated as larger (and thus</span>
<span class="cm">           less well fitting) than any other available chunk since it can</span>
<span class="cm">           be extended to be as large as necessary (up to system</span>
<span class="cm">           limitations).</span>

<span class="cm">           We require that av-&gt;top always exists (i.e., has size &gt;=</span>
<span class="cm">           MINSIZE) after initialization, so if it would otherwise be</span>
<span class="cm">           exhausted by current request, it is replenished. (The main</span>
<span class="cm">           reason for ensuring it exists is that we may need MINSIZE space</span>
<span class="cm">           to put in fenceposts in sysmalloc.)</span>
<span class="cm">         */</span>
        <span class="c1">// 获取当前的top chunk，并计算其对应的大小</span>
        <span class="n">victim</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
        <span class="n">size</span>   <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
        <span class="c1">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
            <span class="n">remainder</span>      <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
            <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span>        <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
            <span class="c1">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span>
            <span class="c1">// top chunk 合并，所以这里设置了 PREV_INUSE。</span>
            <span class="n">set_head</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
                                 <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
            <span class="n">set_head</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>

            <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
            <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 否则，判断是否有 fast chunk</span>
        <span class="cm">/* When we are using atomic ops to free fast chunks we can get</span>
<span class="cm">           here for all block sizes.  */</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 先执行一次fast bin的合并</span>
            <span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
            <span class="cm">/* restore original bin index */</span>
            <span class="c1">// 判断需要的chunk是在small bin范围内还是large bin范围内</span>
            <span class="c1">// 并计算对应的索引</span>
            <span class="c1">// 等待下次再看看是否可以</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
            <span class="k">else</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">largebin_index</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div>
<h3 id="_19">堆内存不够<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<p>如果堆内存不够，我们就需要使用 <code>sysmalloc</code> 来申请内存了。</p>
<div class="highlight"><pre><span></span><code>        <span class="cm">/*</span>
<span class="cm">           Otherwise, relay to handle system-dependent cases</span>
<span class="cm">         */</span>
        <span class="c1">// 否则的话，我们就只能从系统中再次申请一点内存了。</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sysmalloc</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div>
<h2 id="_libc_calloc">_libc_calloc<a class="headerlink" href="#_libc_calloc" title="Permanent link">&para;</a></h2>
<p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code>，具体介绍如下</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">  calloc(size_t n_elements, size_t element_size);</span>
<span class="cm">  Returns a pointer to n_elements * element_size bytes, with all locations</span>
<span class="cm">  set to zero.</span>
<span class="cm">*/</span>
<span class="kt">void</span><span class="o">*</span>  <span class="nf">__libc_calloc</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
</code></pre></div>
<blockquote>
<p>2020.07.08 下面大概浏览一下未仔细品味</p>
</blockquote>
<h2 id="sysmalloc">sysmalloc<a class="headerlink" href="#sysmalloc" title="Permanent link">&para;</a></h2>
<p>正如该函数头的注释所言，该函数用于当前堆内存不足时，需要向系统申请更多的内存。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">   sysmalloc handles malloc cases requiring more memory from the system.</span>
<span class="cm">   On entry, it is assumed that av-&gt;top does not have enough</span>
<span class="cm">   space to service request for nb bytes, thus requiring that av-&gt;top</span>
<span class="cm">   be extended or replaced.</span>
<span class="cm"> */</span>
</code></pre></div>
<h3 id="_20">基本定义<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sysmalloc</span><span class="p">(</span><span class="n">INTERNAL_SIZE_T</span> <span class="n">nb</span><span class="p">,</span> <span class="n">mstate</span> <span class="n">av</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mchunkptr</span> <span class="n">old_top</span><span class="p">;</span>        <span class="cm">/* incoming value of av-&gt;top */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">old_size</span><span class="p">;</span> <span class="cm">/* its size */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">old_end</span><span class="p">;</span>            <span class="cm">/* its end address */</span>

  <span class="kt">long</span> <span class="n">size</span><span class="p">;</span> <span class="cm">/* arg to first MORECORE or mmap call */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">brk</span><span class="p">;</span> <span class="cm">/* return value from MORECORE */</span>

  <span class="kt">long</span> <span class="n">correction</span><span class="p">;</span> <span class="cm">/* arg to 2nd MORECORE call */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">snd_brk</span><span class="p">;</span>   <span class="cm">/* 2nd return val */</span>

  <span class="n">INTERNAL_SIZE_T</span> <span class="n">front_misalign</span><span class="p">;</span> <span class="cm">/* unusable bytes at front of new space */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">end_misalign</span><span class="p">;</span>   <span class="cm">/* partial page left at end of new space */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">aligned_brk</span><span class="p">;</span>              <span class="cm">/* aligned offset into brk */</span>

  <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">;</span>                  <span class="cm">/* the allocated/returned chunk */</span>
  <span class="n">mchunkptr</span> <span class="n">remainder</span><span class="p">;</span>          <span class="cm">/* remainder frOm allocation */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remainder_size</span><span class="p">;</span> <span class="cm">/* its size */</span>

  <span class="kt">size_t</span> <span class="n">pagesize</span> <span class="o">=</span> <span class="n">GLRO</span><span class="p">(</span><span class="n">dl_pagesize</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">tried_mmap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div>
<p>我们可以主要关注一下 <code>pagesize</code>，其</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef EXEC_PAGESIZE</span>
<span class="cp">#define EXEC_PAGESIZE   4096</span>
<span class="cp">#endif</span>
<span class="cp"># define GLRO(name) _##name</span>
<span class="kt">size_t</span> <span class="n">_dl_pagesize</span> <span class="o">=</span> <span class="n">EXEC_PAGESIZE</span><span class="p">;</span>
</code></pre></div>
<p>所以，<code>pagesize=4096=0x1000</code>。</p>
<h3 id="mmap_1">考虑 mmap<a class="headerlink" href="#mmap_1" title="Permanent link">&para;</a></h3>
<p>正如开头注释所言如果满足如下任何一种条件</p>
<ol>
<li>没有分配堆。</li>
<li>申请的内存大于 <code>mp_.mmap_threshold</code>，并且 mmap 的数量小于最大值，就可以尝试使用 mmap。</li>
</ol>
<p>默认情况下，临界值为</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="k">struct</span> <span class="nc">malloc_par</span> <span class="n">mp_</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">top_pad</span> <span class="o">=</span> <span class="n">DEFAULT_TOP_PAD</span><span class="p">,</span>
    <span class="p">.</span><span class="n">n_mmaps_max</span> <span class="o">=</span> <span class="n">DEFAULT_MMAP_MAX</span><span class="p">,</span>
    <span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">=</span> <span class="n">DEFAULT_MMAP_THRESHOLD</span><span class="p">,</span>
    <span class="p">.</span><span class="n">trim_threshold</span> <span class="o">=</span> <span class="n">DEFAULT_TRIM_THRESHOLD</span><span class="p">,</span>
<span class="cp">#define NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span>
    <span class="p">.</span><span class="n">arena_test</span> <span class="o">=</span> <span class="n">NARENAS_FROM_NCORES</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="cp">#if USE_TCACHE</span>
        <span class="p">,</span>
    <span class="p">.</span><span class="n">tcache_count</span> <span class="o">=</span> <span class="n">TCACHE_FILL_COUNT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tcache_bins</span> <span class="o">=</span> <span class="n">TCACHE_MAX_BINS</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tcache_max_bytes</span> <span class="o">=</span> <span class="n">tidx2usize</span><span class="p">(</span><span class="n">TCACHE_MAX_BINS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tcache_unsorted_limit</span> <span class="o">=</span> <span class="mi">0</span> <span class="cm">/* No limit.  */</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</code></pre></div>
<p><code>DEFAULT_MMAP_THRESHOLD</code> 为 128*1024 字节，即 128 K。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef DEFAULT_MMAP_THRESHOLD</span>
<span class="cp">#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm">  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically</span>
<span class="cm">  adjusted MMAP_THRESHOLD.</span>
<span class="cm">*/</span>

<span class="cp">#ifndef DEFAULT_MMAP_THRESHOLD_MIN</span>
<span class="cp">#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef DEFAULT_MMAP_THRESHOLD_MAX</span>
<span class="cm">/* For 32-bit platforms we cannot increase the maximum mmap</span>
<span class="cm">   threshold much because it is also the minimum value for the</span>
<span class="cm">   maximum heap size and its alignment.  Going above 512k (i.e., 1M</span>
<span class="cm">   for new heaps) wastes too much address space.  */</span>
<span class="cp">#if __WORDSIZE == 32</span>
<span class="cp">#define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)</span>
<span class="cp">#else</span>
<span class="cp">#define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>下面为这部分代码，目前不是我们关心的重点，可以暂时跳过。</p>
<div class="highlight"><pre><span></span><code>  <span class="cm">/*</span>
<span class="cm">     If have mmap, and the request size meets the mmap threshold, and</span>
<span class="cm">     the system supports mmap, and there are few enough currently</span>
<span class="cm">     allocated mmapped regions, try to directly map this request</span>
<span class="cm">     rather than expanding top.</span>
<span class="cm">   */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
      <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
       <span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps_max</span><span class="p">)))</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span> <span class="cm">/* return value from mmap call*/</span>

  <span class="nl">try_mmap</span><span class="p">:</span>
    <span class="cm">/*</span>
<span class="cm">       Round up size to nearest page.  For mmapped chunks, the overhead</span>
<span class="cm">       is one SIZE_SZ unit larger than for normal chunks, because there</span>
<span class="cm">       is no following chunk whose prev_size field could be used.</span>

<span class="cm">       See the front_misalign handling below, for glibc there is no</span>
<span class="cm">       need for further alignments unless we have have high alignment.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MALLOC_ALIGNMENT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span>
      <span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">SIZE_SZ</span> <span class="o">+</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">);</span>
    <span class="n">tried_mmap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="cm">/* Don&#39;t try if size wraps around 0 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nb</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">mm</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MMAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*</span>
<span class="cm">           The offset to the start of the mmapped region is stored</span>
<span class="cm">           in the prev_size field of the chunk. This allows us to adjust</span>
<span class="cm">           returned start address to meet alignment requirements here</span>
<span class="cm">           and in memalign(), and still be able to compute proper</span>
<span class="cm">           address argument for later munmap in free() and realloc().</span>
<span class="cm">         */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MALLOC_ALIGNMENT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="p">{</span>
          <span class="cm">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span>
<span class="cm">             MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#39;ed area is page</span>
<span class="cm">             aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span>
          <span class="n">assert</span><span class="p">(((</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">front_misalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span>
          <span class="n">front_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">front_misalign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">correction</span> <span class="o">=</span> <span class="n">MALLOC_ALIGNMENT</span> <span class="o">-</span> <span class="n">front_misalign</span><span class="p">;</span>
          <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)(</span><span class="n">mm</span> <span class="o">+</span> <span class="n">correction</span><span class="p">);</span>
          <span class="n">set_prev_size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">correction</span><span class="p">);</span>
          <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">correction</span><span class="p">)</span> <span class="o">|</span> <span class="n">IS_MMAPPED</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span><span class="n">mm</span><span class="p">;</span>
          <span class="n">set_prev_size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">IS_MMAPPED</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* update statistics */</span>

        <span class="kt">int</span> <span class="n">new</span> <span class="o">=</span> <span class="n">atomic_exchange_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">atomic_max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">max_n_mmaps</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">atomic_exchange_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">mmapped_mem</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">atomic_max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">max_mmapped_mem</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>

        <span class="n">check_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

        <span class="k">return</span> <span class="nf">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>
<h3 id="mmap_2">mmap 失败或者未分配堆<a class="headerlink" href="#mmap_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>  /* There are no usable arenas and mmap also failed.  */
  if (av == NULL)
    return 0;
</code></pre></div>
<p>如果是这两种情况中的任何一种，其实就可以退出了。。</p>
<h3 id="_21">记录旧堆信息<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>  <span class="cm">/* Record incoming configuration of top */</span>

  <span class="n">old_top</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
  <span class="n">old_size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">old_top</span><span class="p">);</span>
  <span class="n">old_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">));</span>

  <span class="n">brk</span> <span class="o">=</span> <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">);</span>
</code></pre></div>
<h3 id="1">检查旧堆信息 1<a class="headerlink" href="#1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>  <span class="cm">/*</span>
<span class="cm">     If not the first time through, we require old_size to be</span>
<span class="cm">     at least MINSIZE and to have prev_inuse set.</span>
<span class="cm">   */</span>

  <span class="n">assert</span><span class="p">((</span><span class="n">old_top</span> <span class="o">==</span> <span class="n">initial_top</span><span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">old_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
         <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">old_size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MINSIZE</span> <span class="o">&amp;&amp;</span> <span class="n">prev_inuse</span><span class="p">(</span><span class="n">old_top</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">old_end</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
</code></pre></div>
<p>这个检查要求满足其中任何一个条件</p>
<ol>
<li><code>old_top == initial_top(av) &amp;&amp; old_size == 0</code>，即如果是第一次的话，堆的大小需要是 0。</li>
<li>新的堆，那么</li>
<li><code>(unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top)</code>，堆的大小应该不小于 <code>MINSIZE</code>，并且前一个堆块应该处于使用中。</li>
<li><code>((unsigned long)old_end &amp; (pagesize - 1)) == 0)</code>，堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。</li>
</ol>
<h3 id="2">检查旧堆信息 2<a class="headerlink" href="#2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>  <span class="cm">/* Precondition: not enough current space to satisfy nb request */</span>
  <span class="n">assert</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">old_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">));</span>
</code></pre></div>
<p>根据 malloc 中的定义</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_int_malloc</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nb</span><span class="p">;</span>  <span class="cm">/* normalized request size */</span>
</code></pre></div>
<p><code>nb</code> 应该是已经加上 chunk 头部的字节，为什么还要加上 <code>MINSIZE</code>呢？这是因为 top chunk 的大小应该至少预留 MINSIZE 空间，以便于合并。</p>
<h3 id="main_arena">非 main_arena<a class="headerlink" href="#main_arena" title="Permanent link">&para;</a></h3>
<p>这里暂时不是关心的重点，暂且不分析。</p>
<div class="highlight"><pre><span></span><code>  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">heap_info</span> <span class="o">*</span><span class="n">old_heap</span><span class="p">,</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">old_heap_size</span><span class="p">;</span>

    <span class="cm">/* First try to extend the current heap. */</span>
    <span class="n">old_heap</span> <span class="o">=</span> <span class="n">heap_for_ptr</span><span class="p">(</span><span class="n">old_top</span><span class="p">);</span>
    <span class="n">old_heap_size</span> <span class="o">=</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">MINSIZE</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">grow_heap</span><span class="p">(</span><span class="n">old_heap</span><span class="p">,</span> <span class="n">MINSIZE</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">old_heap_size</span><span class="p">;</span>
      <span class="n">set_head</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span>
               <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">old_heap</span> <span class="o">+</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">old_top</span><span class="p">)</span> <span class="o">|</span>
                   <span class="n">PREV_INUSE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">heap</span> <span class="o">=</span> <span class="n">new_heap</span><span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="p">(</span><span class="n">MINSIZE</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">heap</span><span class="p">)),</span> <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">)))</span> <span class="p">{</span>
      <span class="cm">/* Use a newly allocated heap.  */</span>
      <span class="n">heap</span><span class="o">-&gt;</span><span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">av</span><span class="p">;</span>
      <span class="n">heap</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">old_heap</span><span class="p">;</span>
      <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
      <span class="cm">/* Set up the new top.  */</span>
      <span class="n">top</span><span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">heap</span><span class="p">));</span>
      <span class="n">set_head</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">av</span><span class="p">),</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">heap</span><span class="p">))</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>

      <span class="cm">/* Setup fencepost and free the old top chunk with a multiple of</span>
<span class="cm">         MALLOC_ALIGNMENT in size. */</span>
      <span class="cm">/* The fencepost takes at least MINSIZE bytes, because it might</span>
<span class="cm">         become the top chunk again later.  Note that a footer is set</span>
<span class="cm">         up, too, although the chunk is marked in use. */</span>
      <span class="n">old_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">-</span> <span class="n">MINSIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>
      <span class="n">set_head</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">),</span>
               <span class="mi">0</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&gt;=</span> <span class="n">MINSIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_head</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">),</span>
                 <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
        <span class="n">set_foot</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">));</span>
        <span class="n">set_head</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span> <span class="n">NON_MAIN_ARENA</span><span class="p">);</span>
        <span class="n">_int_free</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">old_top</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">set_head</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
        <span class="n">set_foot</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tried_mmap</span><span class="p">)</span>
      <span class="cm">/* We can at least try to use to mmap memory.  */</span>
      <span class="k">goto</span> <span class="n">try_mmap</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>
<h3 id="main_arena_1">Main_arena 处理<a class="headerlink" href="#main_arena_1" title="Permanent link">&para;</a></h3>
<h4 id="_22">计算内存<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h4>
<p>计算可以满足请求的内存大小。</p>
<div class="highlight"><pre><span></span><code><span class="k">else</span> <span class="p">{</span> <span class="cm">/* av == main_arena */</span>

    <span class="cm">/* Request enough space for nb + pad + overhead */</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">+</span> <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">;</span>
</code></pre></div>
<p>默认情况下 <code>top_pad</code>定义为</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef DEFAULT_TOP_PAD</span>
<span class="cp"># define DEFAULT_TOP_PAD 131072</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>即 131072 字节，0x20000 字节。</p>
<h4 id="_23">是否连续<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<p>如果我们希望堆的空间连续的话，那么其实可以复用之前的内存。</p>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">       If contiguous, we can subtract out existing space that we hope to</span>
<span class="cm">       combine with new space. We add it back later only if</span>
<span class="cm">       we don&#39;t actually get contiguous space.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">contiguous</span><span class="p">(</span><span class="n">av</span><span class="p">))</span>
      <span class="n">size</span> <span class="o">-=</span> <span class="n">old_size</span><span class="p">;</span>
</code></pre></div>
<h4 id="_24">对齐页大小<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">       Round to a multiple of page size.</span>
<span class="cm">       If MORECORE is not contiguous, this ensures that we only call it</span>
<span class="cm">       with whole-page arguments.  And if MORECORE is contiguous and</span>
<span class="cm">       this is not first time through, this preserves page-alignment of</span>
<span class="cm">       previous calls. Otherwise, we correct to page-align below.</span>
<span class="cm">     */</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">);</span>
</code></pre></div>
<h4 id="_25">申请内存<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">       Don&#39;t try to call MORECORE if argument is so big as to appear</span>
<span class="cm">       negative. Note that since mmap takes size_t arg, it may succeed</span>
<span class="cm">       below even if we cannot call MORECORE.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
      <span class="n">LIBC_PROBE</span><span class="p">(</span><span class="n">memory_sbrk_more</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<h5 id="_26">可能成功<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span> <span class="p">{</span>
      <span class="cm">/* Call the `morecore&#39; hook if necessary.  */</span>
      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span><span class="p">(</span><span class="n">__after_morecore_hook</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)();</span>
    <span class="p">}</span>
</code></pre></div>
<p>这里竟然调用了一个 hook，有点意思。</p>
<h5 id="_27">失败<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h5>
<p>失败，考虑 mmap。</p>
<div class="highlight"><pre><span></span><code><span class="k">else</span> <span class="p">{</span>
      <span class="cm">/*</span>
<span class="cm">         If have mmap, try using it as a backup when MORECORE fails or</span>
<span class="cm">         cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span>
<span class="cm">         address space, so sbrk cannot extend to give contiguous space, but</span>
<span class="cm">         space is available elsewhere.  Note that we ignore mmap max count</span>
<span class="cm">         and threshold limits, since the space will not be used as a</span>
<span class="cm">         segregated mmap region.</span>
<span class="cm">       */</span>

      <span class="cm">/* Cannot merge with old top, so add its size back in */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">contiguous</span><span class="p">(</span><span class="n">av</span><span class="p">))</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">);</span>

      <span class="cm">/* If we are relying on mmap as backup, then use larger units */</span>
      <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">MMAP_AS_MORECORE_SIZE</span><span class="p">))</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">MMAP_AS_MORECORE_SIZE</span><span class="p">;</span>

      <span class="cm">/* Don&#39;t try if size wraps around 0 */</span>
      <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nb</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">mbrk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MMAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mbrk</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
          <span class="cm">/* We do not need, and cannot use, another sbrk call to find end */</span>
          <span class="n">brk</span> <span class="o">=</span> <span class="n">mbrk</span><span class="p">;</span>
          <span class="n">snd_brk</span> <span class="o">=</span> <span class="n">brk</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

          <span class="cm">/*</span>
<span class="cm">             Record that we no longer have a contiguous sbrk region.</span>
<span class="cm">             After the first time mmap is used as backup, we do not</span>
<span class="cm">             ever rely on contiguous space since this could incorrectly</span>
<span class="cm">             bridge regions.</span>
<span class="cm">           */</span>
          <span class="n">set_noncontiguous</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<h4 id="_28">内存可能申请成功<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">sbrk_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mp_</span><span class="p">.</span><span class="n">sbrk_base</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>
      <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
</code></pre></div>
<h5 id="1_1">情况 1<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>      <span class="cm">/*</span>
<span class="cm">         If MORECORE extends previous space, we can likewise extend top size.</span>
<span class="cm">       */</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">==</span> <span class="n">old_end</span> <span class="o">&amp;&amp;</span> <span class="n">snd_brk</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>
        <span class="n">set_head</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
</code></pre></div>
<h5 id="2-">情况 2 - 意外内存耗尽<a class="headerlink" href="#2-" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">contiguous</span><span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">old_size</span> <span class="o">&amp;&amp;</span> <span class="n">brk</span> <span class="o">&lt;</span> <span class="n">old_end</span><span class="p">)</span>
        <span class="cm">/* Oops!  Someone else killed our space..  Can&#39;t touch anything.  */</span>
        <span class="n">malloc_printerr</span><span class="p">(</span><span class="s">&quot;break adjusted to free malloc space&quot;</span><span class="p">);</span>
</code></pre></div>
<h5 id="_29">处理其他意外情况<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>      <span class="cm">/*</span>
<span class="cm">         Otherwise, make adjustments:</span>

<span class="cm">       * If the first time through or noncontiguous, we need to call sbrk</span>
<span class="cm">          just to find out where the end of memory lies.</span>

<span class="cm">       * We need to ensure that all returned chunks from malloc will meet</span>
<span class="cm">          MALLOC_ALIGNMENT</span>

<span class="cm">       * If there was an intervening foreign sbrk, we need to adjust sbrk</span>
<span class="cm">          request size to account for fact that we will not be able to</span>
<span class="cm">          combine new space with existing space in old_top.</span>

<span class="cm">       * Almost all systems internally allocate whole pages at a time, in</span>
<span class="cm">          which case we might as well use the whole last page of request.</span>
<span class="cm">          So we allocate enough more memory to hit a page boundary now,</span>
<span class="cm">          which in turn causes future contiguous calls to page-align.</span>
<span class="cm">       */</span>

      <span class="k">else</span> <span class="p">{</span>
        <span class="n">front_misalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">end_misalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">aligned_brk</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>
</code></pre></div>
<h6 id="_30">处理连续内存<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code>        <span class="cm">/* handle contiguous cases */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">contiguous</span><span class="p">(</span><span class="n">av</span><span class="p">))</span> <span class="p">{</span>
          <span class="cm">/* Count foreign sbrk as system_mem.  */</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span><span class="p">)</span>
            <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">brk</span> <span class="o">-</span> <span class="n">old_end</span><span class="p">;</span>

          <span class="cm">/* Guarantee alignment of first new chunk made from this space */</span>

          <span class="n">front_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">brk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">front_misalign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">               Skip over some bytes to arrive at an aligned position.</span>
<span class="cm">               We don&#39;t need to specially mark these wasted front bytes.</span>
<span class="cm">               They will never be accessed anyway because</span>
<span class="cm">               prev_inuse of av-&gt;top (and any chunk created from its start)</span>
<span class="cm">               is always true after initialization.</span>
<span class="cm">             */</span>

            <span class="n">correction</span> <span class="o">=</span> <span class="n">MALLOC_ALIGNMENT</span> <span class="o">-</span> <span class="n">front_misalign</span><span class="p">;</span>
            <span class="n">aligned_brk</span> <span class="o">+=</span> <span class="n">correction</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="cm">/*</span>
<span class="cm">             If this isn&#39;t adjacent to existing space, then we will not</span>
<span class="cm">             be able to merge with old_top space, so must add to 2nd request.</span>
<span class="cm">           */</span>

          <span class="n">correction</span> <span class="o">+=</span> <span class="n">old_size</span><span class="p">;</span>

          <span class="cm">/* Extend the end address to hit a page boundary */</span>
          <span class="n">end_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)(</span><span class="n">brk</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">correction</span><span class="p">);</span>
          <span class="n">correction</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">end_misalign</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">))</span> <span class="o">-</span> <span class="n">end_misalign</span><span class="p">;</span>

          <span class="n">assert</span><span class="p">(</span><span class="n">correction</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
          <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE</span><span class="p">(</span><span class="n">correction</span><span class="p">));</span>

          <span class="cm">/*</span>
<span class="cm">             If can&#39;t allocate correction, try to at least find out current</span>
<span class="cm">             brk.  It might be enough to proceed without failing.</span>

<span class="cm">             Note that if second sbrk did NOT fail, we assume that space</span>
<span class="cm">             is contiguous with first sbrk. This is a safe assumption unless</span>
<span class="cm">             program is multithreaded but doesn&#39;t use locks and a foreign sbrk</span>
<span class="cm">             occurred between our first and second calls.</span>
<span class="cm">           */</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Call the `morecore&#39; hook if necessary.  */</span>
            <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span><span class="p">(</span><span class="n">__after_morecore_hook</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
              <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)();</span>
          <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>
<h6 id="_31">处理不连续内存<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code>        <span class="cm">/* handle non-contiguous cases */</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MALLOC_ALIGNMENT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span>
            <span class="cm">/* MORECORE/mmap must correctly align */</span>
            <span class="n">assert</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">brk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
          <span class="k">else</span> <span class="p">{</span>
            <span class="n">front_misalign</span> <span class="o">=</span>
                <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">brk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">front_misalign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="cm">/*</span>
<span class="cm">                 Skip over some bytes to arrive at an aligned position.</span>
<span class="cm">                 We don&#39;t need to specially mark these wasted front bytes.</span>
<span class="cm">                 They will never be accessed anyway because</span>
<span class="cm">                 prev_inuse of av-&gt;top (and any chunk created from its start)</span>
<span class="cm">                 is always true after initialization.</span>
<span class="cm">               */</span>

              <span class="n">aligned_brk</span> <span class="o">+=</span> <span class="n">MALLOC_ALIGNMENT</span> <span class="o">-</span> <span class="n">front_misalign</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">}</span>

          <span class="cm">/* Find out current end of memory */</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
          <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>
<h6 id="_32">调整<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code>        <span class="cm">/* Adjust top based on results of second sbrk */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span><span class="n">aligned_brk</span><span class="p">;</span>
          <span class="n">set_head</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">-</span> <span class="n">aligned_brk</span> <span class="o">+</span> <span class="n">correction</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
          <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">correction</span><span class="p">;</span>

          <span class="cm">/*</span>
<span class="cm">             If not the first time through, we either have a</span>
<span class="cm">             gap due to foreign sbrk or a non-contiguous region.  Insert a</span>
<span class="cm">             double fencepost at old_top to prevent consolidation with space</span>
<span class="cm">             we don&#39;t own. These fenceposts are artificial chunks that are</span>
<span class="cm">             marked as inuse and are in any case too small to use.  We need</span>
<span class="cm">             two to make sizes and alignments work out.</span>
<span class="cm">           */</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">               Shrink old_top to insert fenceposts, keeping size a</span>
<span class="cm">               multiple of MALLOC_ALIGNMENT. We know there is at least</span>
<span class="cm">               enough space in old_top to do this.</span>
<span class="cm">             */</span>
            <span class="n">old_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>
            <span class="n">set_head</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>

            <span class="cm">/*</span>
<span class="cm">               Note that the following assignments completely overwrite</span>
<span class="cm">               old_top when old_size was previously MINSIZE.  This is</span>
<span class="cm">               intentional. We need the fencepost, even if old_top otherwise</span>
<span class="cm">               gets lost.</span>
<span class="cm">             */</span>
            <span class="n">set_head</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">),</span>
                     <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
            <span class="n">set_head</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">),</span>
                     <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>

            <span class="cm">/* If possible, release the rest. */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&gt;=</span> <span class="n">MINSIZE</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">_int_free</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">old_top</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>
<p>需要注意的是，在这里程序将旧的 top chunk 进行了释放，那么其会根据大小进入不同的 bin 或 tcache 中。</p>
<h4 id="_33">更新最大内存<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">max_system_mem</span><span class="p">))</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">max_system_mem</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">;</span>
  <span class="n">check_malloc_state</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
</code></pre></div>
<h4 id="_34">分配内存块<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h4>
<h5 id="_35">获取大小<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>  <span class="cm">/* finally, do the allocation */</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></div>
<h5 id="top">切分 TOP<a class="headerlink" href="#top" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code>  <span class="cm">/* check that one of the above allocation paths succeeded */</span>
  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
    <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">set_head</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
    <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>
<h4 id="_36">捕捉所有错误<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>  <span class="cm">/* catch all failure paths */</span>
  <span class="n">__set_errno</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<h1 id="_37">释放内存块<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Free Heap Memory</p>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="__libc_free">__libc_free<a class="headerlink" href="#__libc_free" title="Permanent link">&para;</a></h2>
<p>类似于 malloc，free 函数也有一层封装，命名格式与 malloc 基本类似。代码如下</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">__libc_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mstate</span>    <span class="n">ar_ptr</span><span class="p">;</span>
    <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* chunk corresponding to mem */</span>
    <span class="c1">// 判断是否有钩子函数 __free_hook</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span><span class="p">(</span><span class="n">__free_hook</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">//执行hook函数然后返回</span>
        <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">mem</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// free NULL没有作用</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* free(0) has no effect */</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="c1">// 将mem转换为chunk状态</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">mem2chunk</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
    <span class="c1">// 如果该块内存是mmap得到的</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="cm">/* release mmapped memory. */</span>
    <span class="p">{</span>
        <span class="cm">/* See if the dynamic brk/mmap threshold needs adjusting.</span>
<span class="cm">       Dumped fake mmapped chunks do not affect the threshold.  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span> <span class="o">&amp;&amp;</span> <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">&amp;&amp;</span>
            <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">DEFAULT_MMAP_THRESHOLD_MAX</span> <span class="o">&amp;&amp;</span>
            <span class="o">!</span><span class="n">DUMPED_MAIN_ARENA_CHUNK</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">;</span>
            <span class="n">LIBC_PROBE</span><span class="p">(</span><span class="n">memory_mallopt_free_dyn_thresholds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">munmap_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 根据chunk获得分配区的指针</span>
    <span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_for_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="c1">// 执行释放</span>
    <span class="n">_int_free</span><span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_int_free">_int_free<a class="headerlink" href="#_int_free" title="Permanent link">&para;</a></h2>
<p>函数初始时刻定义了一系列的变量，并且得到了用户想要释放的 chunk 的大小</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="n">_int_free</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>      <span class="cm">/* its size */</span>
    <span class="n">mfastbinptr</span> <span class="o">*</span>   <span class="n">fb</span><span class="p">;</span>        <span class="cm">/* associated fastbin */</span>
    <span class="n">mchunkptr</span>       <span class="n">nextchunk</span><span class="p">;</span> <span class="cm">/* next contiguous chunk */</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>  <span class="cm">/* its size */</span>
    <span class="kt">int</span>             <span class="n">nextinuse</span><span class="p">;</span> <span class="cm">/* true if nextchunk is used */</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>  <span class="cm">/* size of previous contiguous chunk */</span>
    <span class="n">mchunkptr</span>       <span class="n">bck</span><span class="p">;</span>       <span class="cm">/* misc temp for linking */</span>
    <span class="n">mchunkptr</span>       <span class="n">fwd</span><span class="p">;</span>       <span class="cm">/* misc temp for linking */</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></div>
<h3 id="_38">简单的检查<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>    <span class="cm">/* Little security check which won&#39;t hurt performance: the</span>
<span class="cm">       allocator never wrapps around at the end of the address space.</span>
<span class="cm">       Therefore we can exclude some size values which might appear</span>
<span class="cm">       here by accident or by &quot;design&quot; from some intruder.  */</span>
    <span class="c1">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span>
    <span class="c1">// 指针必须得对齐，2*SIZE_SZ 这个对齐得仔细想想</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">__builtin_expect</span><span class="p">(</span><span class="n">misaligned_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;free(): invalid pointer&quot;</span><span class="p">;</span>
    <span class="nl">errout</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">locked</span><span class="p">)</span> <span class="n">__libc_lock_unlock</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">malloc_printerr</span><span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">av</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* We know that each chunk is at least MINSIZE bytes in size or a</span>
<span class="cm">       multiple of MALLOC_ALIGNMENT.  */</span>
    <span class="c1">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span> <span class="o">||</span> <span class="o">!</span><span class="n">aligned_OK</span><span class="p">(</span><span class="n">size</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;free(): invalid size&quot;</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span>
    <span class="n">check_inuse_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</code></pre></div>
<p>其中</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Check if m has acceptable alignment */</span>

<span class="cp">#define aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span>

<span class="cp">#define misaligned_chunk(p)                                                    \</span>
<span class="cp">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span>
<span class="cp">     MALLOC_ALIGN_MASK)</span>
</code></pre></div>
<h3 id="fast-bin_2">fast bin<a class="headerlink" href="#fast-bin_2" title="Permanent link">&para;</a></h3>
<p>如果上述检查都合格的话，判断当前的 bin 是不是在 fast bin 范围内，在的话就插入到 <strong>fastbin 头部</strong>，即成为对应 fastbin 链表的**第一个 free chunk**。</p>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">      If eligible, place chunk on a fastbin so it can be found</span>
<span class="cm">      and used quickly in malloc.</span>
<span class="cm">    */</span>

    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">get_max_fast</span><span class="p">())</span>

<span class="cp">#if TRIM_FASTBINS</span>
        <span class="cm">/*</span>
<span class="cm">      If TRIM_FASTBINS set, don&#39;t place chunks</span>
<span class="cm">      bordering top into fastbins</span>
<span class="cm">        */</span>
       <span class="c1">//默认 #define TRIM_FASTBINS 0，因此默认情况下下面的语句不会执行</span>
       <span class="c1">// 如果当前chunk是fast chunk，并且下一个chunk是top chunk，则不能插入</span>
       <span class="c1">// 因为下一个chunk是topchunk 直接与 topchunk 合并</span>
        <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span>
<span class="cp">#endif</span>
            <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 下一个chunk的大小不能小于两倍的SIZE_SZ,并且</span>
        <span class="c1">// 下一个chunk的大小不能大于system_mem， 一般为132k</span>
        <span class="c1">// 如果出现这样的情况，就报错。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span>
                <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">__builtin_expect</span><span class="p">(</span>
                <span class="n">chunksize</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* We might not have a lock at this point and concurrent</span>
<span class="cm">               modifications</span>
<span class="cm">               of system_mem might have let to a false positive.  Redo the test</span>
<span class="cm">               after getting the lock.  */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">||</span> <span class="p">({</span>
                    <span class="n">assert</span><span class="p">(</span><span class="n">locked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="n">__libc_lock_lock</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
                    <span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">||</span>
                        <span class="n">chunksize</span><span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">;</span>
                <span class="p">}))</span> <span class="p">{</span>
                <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;free(): invalid next size (fast)&quot;</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__libc_lock_unlock</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
                <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 将chunk的mem部分全部设置为perturb_byte</span>
        <span class="n">free_perturb</span><span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>
        <span class="c1">// 设置fast chunk的标记位</span>
        <span class="n">set_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
        <span class="c1">// 根据大小获取fast bin的索引</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
        <span class="c1">// 获取对应fastbin的头指针，被初始化后为NULL。</span>
        <span class="n">fb</span>               <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

        <span class="cm">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span>
        <span class="c1">// 使用原子操作将P插入到链表中</span>
        <span class="n">mchunkptr</span>    <span class="n">old</span>     <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span> <span class="n">old2</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_idx</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0u</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="cm">/* Check that the top of the bin is not the record we are going to</span>
<span class="cm">               add</span>
<span class="cm">               (i.e., double free).  */</span>
            <span class="c1">// so we can not double free one fastbin chunk</span>
            <span class="c1">// 防止对 fast bin double free</span>
            <span class="c1">// 防御方法是通过检查上一个chunk是否和新释放的chunk地址相同</span>
            <span class="c1">// 绕过方法就是在中间夹杂一个其他chunk，比如需要doublefree A，释放顺序为：</span>
            <span class="c1">// free A、free B、free A</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;double free or corruption (fasttop)&quot;</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Check that size of fastbin chunk at the top is the same as</span>
<span class="cm">               size of the chunk that we are adding.  We can dereference OLD</span>
<span class="cm">               only if we have the lock, otherwise it might have already been</span>
<span class="cm">               deallocated.  See use of OLD_IDX below for the actual check.  */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">old_idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">old</span><span class="p">));</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">old2</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">old</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_rel</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">old2</span><span class="p">))</span> <span class="o">!=</span>
                 <span class="n">old2</span><span class="p">);</span>
        <span class="c1">// 确保fast bin的加入前与加入后相同</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">__builtin_expect</span><span class="p">(</span><span class="n">old_idx</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;invalid fastbin entry (free)&quot;</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="mmap-chunk">合并非 mmap 的空闲 chunk<a class="headerlink" href="#mmap-chunk" title="Permanent link">&para;</a></h3>
<p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong></p>
<p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p>
<ul>
<li>先考虑物理低地址空闲块</li>
<li>后考虑物理高地址空闲块</li>
</ul>
<p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong></p>
<p>在没有锁的情况下，先获得锁。</p>
<div class="highlight"><pre><span></span><code>    <span class="cm">/*</span>
<span class="cm">      Consolidate other non-mmapped chunks as they arrive.</span>
<span class="cm">    */</span>

    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk_is_mmapped</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">__libc_lock_lock</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
            <span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">nextchunk</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div>
<h4 id="_39">轻量级的检测<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>        <span class="cm">/* Lightweight tests: check whether the block is already the</span>
<span class="cm">           top block.  */</span>
        <span class="c1">// 当前free的chunk不能是top chunk</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;double free or corruption (top)&quot;</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 当前free的chunk的下一个chunk不能超过arena的边界</span>
        <span class="cm">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">contiguous</span><span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                                 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nextchunk</span> <span class="o">&gt;=</span>
                                     <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)),</span>
                             <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;double free or corruption (out)&quot;</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 当前要free的chunk的使用标记没有被标记，double free</span>
        <span class="cm">/* Or whether the block is actually not marked used.  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;double free or corruption (!prev)&quot;</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 下一个chunk的大小</span>
        <span class="n">nextsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">);</span>
        <span class="c1">// next chunk size valid check</span>
        <span class="c1">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span>
        <span class="c1">// nextsize是否大于系统可提供的内存</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">chunksize_nomask</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">__builtin_expect</span><span class="p">(</span><span class="n">nextsize</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;free(): invalid next size (normal)&quot;</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div>
<h4 id="_40">释放填充<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>        <span class="c1">//将指针的mem部分全部设置为perturb_byte</span>
        <span class="n">free_perturb</span><span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>
</code></pre></div>
<h4 id="-chunk">后向合并 - 合并低地址 chunk<a class="headerlink" href="#-chunk" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>        <span class="cm">/* consolidate backward */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">prevsize</span> <span class="o">=</span> <span class="n">prev_size</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>
            <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div>
<h4 id="top-chunk-chunk">下一块不是 top chunk - 前向合并 - 合并高地址 chunk<a class="headerlink" href="#top-chunk-chunk" title="Permanent link">&para;</a></h4>
<p>需要注意的是，如果下一块不是 top chunk ，则合并高地址的 chunk ，并将合并后的 chunk 放入到 unsorted bin 中。</p>
<div class="highlight"><pre><span></span><code>        <span class="c1">// 如果下一个chunk不是top chunk</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextchunk</span> <span class="o">!=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* get and clear inuse bit */</span>
            <span class="c1">// 获取下一个 chunk 的使用状态</span>
            <span class="n">nextinuse</span> <span class="o">=</span> <span class="n">inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="n">nextsize</span><span class="p">);</span>
            <span class="c1">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span>
            <span class="cm">/* consolidate forward */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextinuse</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">nextchunk</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span>
                <span class="n">clear_inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

            <span class="cm">/*</span>
<span class="cm">          Place the chunk in unsorted chunk list. Chunks are</span>
<span class="cm">          not placed into regular bins until after they have</span>
<span class="cm">          been given one chance to be used in malloc.</span>
<span class="cm">            */</span>
            <span class="c1">// 把 chunk 放在 unsorted chunk 链表的头部</span>
            <span class="c1">// unsorted bin 链头</span>
            <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
            <span class="c1">// unsorted bin 顺数第一个（最新放入）</span>
            <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
            <span class="c1">// 简单的检查</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;free(): corrupted unsorted chunks&quot;</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
            <span class="c1">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

            <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
            <span class="n">set_foot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

            <span class="n">check_free_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div>
<h4 id="top-chunk-top-chunk">下一块是 top chunk - 合并到 top chunk<a class="headerlink" href="#top-chunk-top-chunk" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>        <span class="cm">/*</span>
<span class="cm">          If the chunk borders the current high end of memory,</span>
<span class="cm">          consolidate into top</span>
<span class="cm">        */</span>
        <span class="c1">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>
            <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
            <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">check_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div>
<h4 id="_41">向系统返还内存<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>        <span class="cm">/*</span>
<span class="cm">          If freeing a large space, consolidate possibly-surrounding</span>
<span class="cm">          chunks. Then, if the total unused topmost memory exceeds trim</span>
<span class="cm">          threshold, ask malloc_trim to reduce top.</span>

<span class="cm">          Unless max_fast is 0, we don&#39;t know if there are fastbins</span>
<span class="cm">          bordering top, so we cannot tell for sure whether threshold</span>
<span class="cm">          has been reached unless fastbins are consolidated.  But we</span>
<span class="cm">          don&#39;t want to consolidate on each free.  As a compromise,</span>
<span class="cm">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span>
<span class="cm">          is reached.</span>
<span class="cm">        */</span>
         <span class="c1">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span>
         <span class="c1">// 一般合并到 top chunk 都会执行这部分代码。</span>
         <span class="c1">// 那就向系统返还内存</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">FASTBIN_CONSOLIDATION_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果有 fast chunk 就进行合并</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">))</span> <span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
            <span class="c1">// 主分配区</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef MORECORE_CANNOT_TRIM</span>
                <span class="c1">// top chunk 大于当前的收缩阙值</span>
                <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span> <span class="o">&gt;=</span>
                    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">))</span>
                    <span class="n">systrim</span><span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
<span class="cp">#endif      </span><span class="c1">// 非主分配区，则直接收缩heap</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Always try heap_trim(), even if the top chunk is not</span>
<span class="cm">                   large, because the corresponding heap might go away.  */</span>
                <span class="n">heap_info</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">heap_for_ptr</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">av</span><span class="p">));</span>

                <span class="n">assert</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">ar_ptr</span> <span class="o">==</span> <span class="n">av</span><span class="p">);</span>
                <span class="n">heap_trim</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">locked</span><span class="p">);</span>
            <span class="n">__libc_lock_unlock</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div>
<h3 id="mmap-chunk_1">释放 mmap 的 chunk<a class="headerlink" href="#mmap-chunk_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//  If the chunk was allocated via mmap, release via munmap().</span>
        <span class="n">munmap_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<h2 id="systrim">systrim<a class="headerlink" href="#systrim" title="Permanent link">&para;</a></h2>
<h2 id="heap_trim">heap_trim<a class="headerlink" href="#heap_trim" title="Permanent link">&para;</a></h2>
<h2 id="munmap_chunk">munmap_chunk<a class="headerlink" href="#munmap_chunk" title="Permanent link">&para;</a></h2>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>这里意思是去对应 bin 取，没有办法取到。比如需要一个 0x100 的chunk ，去到大小为 0x100 的bin 中取，而该 bin 中没有空闲 chunk 。&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>实际上还需进行对齐等操作，返回内存块不一定是对应大小的&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>还需要根据内存块的物理位置判断是否还给系统&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>也就是相当于 malloc 是一个整合包，打包好实现申请堆块需要用到的所有函数。类似的函数还有 system 等&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            <span>&copy; 2021</span>by <a href="https://www.mrskye.cn/" target="_blank">SkYe231</a> &nbsp;|&nbsp; <span><a href="http://beian.miit.gov.cn/" target="_blank">粤ICP备20056619号</a></span>
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/vendor.93c04032.min.js"></script>
      <script src="../../../assets/javascripts/bundle.83e5331e.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../../..",
          features: {'tabs': True},
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.8c7e0a7e.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>